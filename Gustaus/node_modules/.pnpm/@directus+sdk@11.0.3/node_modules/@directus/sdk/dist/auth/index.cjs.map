{"version":3,"sources":["../../src/auth/index.ts","../../src/utils/request.ts","../../src/rest/utils/query-to-params.ts","../../src/utils/get-request-url.ts","../../src/auth/utils/memory-storage.ts","../../src/auth/composable.ts","../../src/auth/static.ts"],"sourcesContent":["export * from './composable.js';\nexport * from './static.js';\nexport * from './utils/memory-storage.js';\nexport type * from './types.js';\n","/**\n * Request helper providing default settings\n *\n * @param url The request URL\n * @param options The request options\n *\n * @returns The API result if successful\n */\nexport const request = async <Output = any>(\n\turl: string,\n\toptions: RequestInit,\n\tformatter?: ((data: any) => Output) | null\n): Promise<Output> => {\n\toptions.headers =\n\t\ttypeof options.headers === 'object' && !Array.isArray(options.headers)\n\t\t\t? (options.headers as Record<string, string>)\n\t\t\t: {};\n\n\tconst defaultFormatter = (data: Output | { data: Output }) => {\n\t\tif (typeof data === 'object' && data && 'data' in data) {\n\t\t\treturn data.data;\n\t\t}\n\n\t\treturn data;\n\t};\n\n\tconst outputFormatter = formatter !== undefined && formatter !== null ? formatter : defaultFormatter;\n\n\tconst response = await globalThis\n\t\t.fetch(url, options)\n\t\t.then(async (response) => {\n\t\t\tconst type = response.headers.get('Content-Type')?.toLowerCase();\n\n\t\t\tif (type?.startsWith('application/json')) {\n\t\t\t\tconst result = await response.json();\n\t\t\t\tif (!response.ok) throw result;\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (type?.startsWith('text/html') || type?.startsWith('text/plain')) {\n\t\t\t\tconst result = await response.text();\n\t\t\t\tif (!response.ok) throw result;\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// empty body fallback\n\t\t\treturn;\n\t\t})\n\t\t.catch((err) => {\n\t\t\tthrow err;\n\t\t});\n\n\treturn outputFormatter(response);\n};\n","import type { AggregationTypes, GroupByFields, Query } from '../../types/index.js';\n\ntype ExtendedQuery<Schema extends object, Item> = Query<Schema, Item> & {\n\taggregate?: Record<keyof AggregationTypes, string>;\n\tgroupBy?: (string | GroupByFields<Schema, Item>)[];\n};\n\n/**\n * Transform nested query object to an url compatible format\n *\n * @param query The nested query object\n *\n * @returns Flat query parameters\n */\nexport const queryToParams = <Schema extends object, Item>(\n\tquery: ExtendedQuery<Schema, Item>\n): Record<string, string> => {\n\tconst params: Record<string, string> = {};\n\n\tif (Array.isArray(query.fields) && query.fields.length > 0) {\n\t\ttype FieldItem = (typeof query.fields)[number];\n\n\t\tconst walkFields = (value: FieldItem, chain: string[] = []): string | string[] => {\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tconst result = [];\n\n\t\t\t\tfor (const key in value) {\n\t\t\t\t\tconst nestedField = value[key as keyof typeof value] ?? [];\n\n\t\t\t\t\tif (Array.isArray(nestedField)) {\n\t\t\t\t\t\t// regular nested fields\n\t\t\t\t\t\tfor (const item of nestedField) {\n\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, key]));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof nestedField === 'object') {\n\t\t\t\t\t\t// many to any nested\n\t\t\t\t\t\tfor (const scope of Object.keys(nestedField)) {\n\t\t\t\t\t\t\tconst fields = (nestedField as Record<string, FieldItem[]>)[scope]!;\n\n\t\t\t\t\t\t\tfor (const item of fields) {\n\t\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, `${key}:${scope}`]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result.flatMap((items) => items);\n\t\t\t}\n\n\t\t\treturn [...chain, String(value)].join('.');\n\t\t};\n\n\t\tparams['fields'] = query.fields.flatMap((value) => walkFields(value)).join(',');\n\t}\n\n\tif (query.filter && Object.keys(query.filter).length > 0) {\n\t\tparams['filter'] = JSON.stringify(query.filter);\n\t}\n\n\tif (query.search) {\n\t\t// covers both empty string and undefined\n\t\tparams['search'] = query.search;\n\t}\n\n\tif ('sort' in query && query.sort) {\n\t\t// covers empty array and undefined\n\t\tparams['sort'] = typeof query.sort === 'string' ? query.sort : query.sort.join(',');\n\t}\n\n\tif (typeof query.limit === 'number' && query.limit >= -1) {\n\t\tparams['limit'] = String(query.limit);\n\t}\n\n\tif (typeof query.offset === 'number' && query.offset >= 0) {\n\t\tparams['offset'] = String(query.offset);\n\t}\n\n\tif (typeof query.page === 'number' && query.page >= 1) {\n\t\tparams['page'] = String(query.page);\n\t}\n\n\tif (query.deep && Object.keys(query.deep).length > 0) {\n\t\tparams['deep'] = JSON.stringify(query.deep);\n\t}\n\n\tif (query.alias && Object.keys(query.alias).length > 0) {\n\t\tparams['alias'] = JSON.stringify(query.alias);\n\t}\n\n\tif (query.aggregate && Object.keys(query.aggregate).length > 0) {\n\t\tparams['aggregate'] = JSON.stringify(query.aggregate);\n\t}\n\n\tif (query.groupBy && query.groupBy.length > 0) {\n\t\tparams['groupBy'] = query.groupBy.join(',');\n\t}\n\n\treturn params;\n};\n","import { queryToParams } from '../index.js';\n\nconst SEPARATOR = '/';\n\nconst mergePaths = (a: string, b: string) => {\n\tif (a.endsWith(SEPARATOR)) a = a.slice(0, -1);\n\tif (!b.startsWith(SEPARATOR)) b = SEPARATOR + b;\n\treturn a + b;\n};\n\n/**\n * Build URL based on provided options\n *\n * @param baseUrl The base URL\n * @param options The request options\n *\n * @returns URL\n */\nexport const getRequestUrl = (baseUrl: URL, path: string, params?: Record<string, any>): URL => {\n\tconst newPath = baseUrl.pathname === SEPARATOR ? path : mergePaths(baseUrl.pathname, path);\n\tconst url = new globalThis.URL(newPath, baseUrl);\n\n\tif (params) {\n\t\tfor (const [k, v] of Object.entries(queryToParams(params))) {\n\t\t\tif (v && typeof v === 'object' && !Array.isArray(v)) {\n\t\t\t\tfor (const [k2, v2] of Object.entries(v)) {\n\t\t\t\t\turl.searchParams.set(`${k}[${k2}]`, String(v2));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\turl.searchParams.set(k, v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn url;\n};\n","import type { AuthenticationStorage, AuthenticationData } from '../types.js';\n\n/**\n * Simple memory storage implementation\n *\n * @returns AuthenticationStorage\n */\nexport const memoryStorage = () => {\n\tlet store: AuthenticationData | null = null;\n\n\treturn {\n\t\tget: async () => store,\n\t\tset: async (value: AuthenticationData | null) => {\n\t\t\tstore = value;\n\t\t},\n\t} as AuthenticationStorage;\n};\n","import type { loginOptions } from '../index.js';\nimport type { DirectusClient } from '../types/client.js';\nimport { getRequestUrl } from '../utils/get-request-url.js';\nimport { request } from '../utils/request.js';\nimport type { AuthenticationClient, AuthenticationConfig, AuthenticationData, AuthenticationMode } from './types.js';\nimport { memoryStorage } from './utils/memory-storage.js';\n\nconst defaultConfigValues = {\n\tmsRefreshBeforeExpires: 30000, // 30 seconds\n\tautoRefresh: true,\n};\n\n/**\n * Creates a client to authenticate with Directus.\n *\n * @param mode AuthenticationMode\n * @param config The optional configuration.\n *\n * @returns A Directus authentication client.\n */\nexport const authentication = (mode: AuthenticationMode = 'cookie', config: AuthenticationConfig = {}) => {\n\treturn <Schema extends object>(client: DirectusClient<Schema>): AuthenticationClient<Schema> => {\n\t\tconfig = { ...defaultConfigValues, ...config };\n\t\tlet refreshPromise: Promise<AuthenticationData> | null = null;\n\t\tlet refreshTimeout: NodeJS.Timer | null = null;\n\t\tconst storage = config.storage ?? memoryStorage();\n\n\t\tconst autoRefresh = 'autoRefresh' in config ? config.autoRefresh : defaultConfigValues.autoRefresh;\n\n\t\tconst msRefreshBeforeExpires =\n\t\t\ttypeof config.msRefreshBeforeExpires === 'number'\n\t\t\t\t? config.msRefreshBeforeExpires\n\t\t\t\t: defaultConfigValues.msRefreshBeforeExpires;\n\n\t\tconst resetStorage = () => {\n\t\t\tstorage.set({ access_token: null, refresh_token: null, expires: null, expires_at: null });\n\t\t};\n\n\t\tconst activeRefresh = async () => {\n\t\t\ttry {\n\t\t\t\tawait refreshPromise;\n\t\t\t} finally {\n\t\t\t\trefreshPromise = null;\n\t\t\t}\n\t\t};\n\n\t\tconst refreshIfExpired = async () => {\n\t\t\tconst authData = await storage.get();\n\n\t\t\tif (refreshPromise || !authData?.expires_at) {\n\t\t\t\tawait activeRefresh();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (authData.expires_at < new Date().getTime() + msRefreshBeforeExpires) {\n\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t/* throw err; */\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait activeRefresh();\n\t\t};\n\n\t\tconst setCredentials = (data: AuthenticationData) => {\n\t\t\tconst expires = data.expires ?? 0;\n\t\t\tdata.expires_at = new Date().getTime() + expires;\n\t\t\tstorage.set(data);\n\n\t\t\tif (autoRefresh && expires > msRefreshBeforeExpires && expires < Number.MAX_SAFE_INTEGER) {\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\n\t\t\t\trefreshTimeout = setTimeout(() => {\n\t\t\t\t\trefreshTimeout = null;\n\n\t\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t\t/* throw err; */\n\t\t\t\t\t});\n\t\t\t\t}, expires - msRefreshBeforeExpires);\n\t\t\t}\n\t\t};\n\n\t\tconst refresh = async () => {\n\t\t\tconst awaitRefresh = async () => {\n\t\t\t\tconst authData = await storage.get();\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst options = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t} as RequestInit;\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\toptions.body = JSON.stringify({\n\t\t\t\t\t\trefresh_token: authData.refresh_token,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/refresh');\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), options).catch((err) => {\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\trefreshPromise = awaitRefresh().catch((err) => {\n\t\t\t\tthrow err;\n\t\t\t});\n\n\t\t\treturn refreshPromise;\n\t\t};\n\n\t\treturn {\n\t\t\trefresh,\n\t\t\tasync login(email: string, password: string, options: loginOptions = {}) {\n\t\t\t\t// TODO: allow for websocket only authentication\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst authPath = options.provider ? `/auth/login/${options.provider}` : '/auth/login';\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, authPath);\n\n\t\t\t\tconst authData: Record<string, string> = { email, password };\n\t\t\t\tif ('otp' in options) authData['otp'] = options.otp;\n\t\t\t\tif ('mode' in options) authData['mode'] = options.mode;\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify(authData),\n\t\t\t\t});\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t},\n\t\t\tasync logout() {\n\t\t\t\tconst authData = await storage.get();\n\n\t\t\t\tconst options: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\toptions.body = JSON.stringify({\n\t\t\t\t\t\trefresh_token: authData.refresh_token,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/logout');\n\t\t\t\tawait request(requestUrl.toString(), options, null);\n\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\t\t\t\tresetStorage();\n\t\t\t},\n\t\t\tasync getToken() {\n\t\t\t\tawait refreshIfExpired();\n\n\t\t\t\tconst data = await storage.get();\n\t\t\t\treturn data?.access_token ?? null;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\tstorage.set({\n\t\t\t\t\taccess_token,\n\t\t\t\t\trefresh_token: null,\n\t\t\t\t\texpires: null,\n\t\t\t\t\texpires_at: null,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t};\n};\n","import type { DirectusClient } from '../types/client.js';\nimport type { StaticTokenClient } from './types.js';\n\n/**\n * Creates a client to authenticate with Directus using a static token.\n *\n * @param token static token.\n *\n * @returns A Directus static token client.\n */\nexport const staticToken = (access_token: string) => {\n\treturn <Schema extends object>(_client: DirectusClient<Schema>): StaticTokenClient<Schema> => {\n\t\tlet token: string | null = access_token ?? null;\n\t\treturn {\n\t\t\tasync getToken() {\n\t\t\t\treturn token;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\ttoken = access_token;\n\t\t\t},\n\t\t};\n\t};\n};\n"],"mappings":"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","names":["auth_exports","__export","authentication","memoryStorage","staticToken","__toCommonJS","request","url","options","formatter","outputFormatter","data","response","type","result","err","queryToParams","query","params","walkFields","value","chain","result","key","nestedField","item","scope","fields","items","SEPARATOR","mergePaths","a","b","getRequestUrl","baseUrl","path","params","newPath","url","k","v","queryToParams","k2","v2","memoryStorage","store","value","defaultConfigValues","authentication","mode","config","client","refreshPromise","refreshTimeout","storage","memoryStorage","autoRefresh","msRefreshBeforeExpires","resetStorage","activeRefresh","refreshIfExpired","authData","refresh","_err","setCredentials","data","expires","options","requestUrl","getRequestUrl","request","err","email","password","authPath","access_token","staticToken","access_token","_client","token"]}