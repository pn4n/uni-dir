function m(t){return JSON.stringify({...t,type:"auth"})}var w=()=>JSON.stringify({type:"pong"});var y=t=>new Promise((u,r)=>{let h=S=>{try{let a=JSON.parse(S.data);typeof a=="object"&&!Array.isArray(a)&&a!==null&&(t.removeEventListener("message",h),u(a))}catch{t.removeEventListener("message",h),u(S)}};t.addEventListener("message",h),t.addEventListener("error",()=>r()),t.addEventListener("close",()=>r())});function*g(){let t=1;for(;;)yield String(t),t++}var x={authMode:"handshake",heartbeat:!0,reconnect:{delay:1e3,retries:10}};function j(t={}){return u=>{t={...x,...t};let r=null,h=g(),S=0,a=!1,f=e=>"getToken"in e,b=async(e,n)=>{if(t.authMode==="strict"&&f(n)){let o=await n.getToken();o&&e.searchParams.set("access_token",o)}return e},v=async e=>{if("url"in t)return await b(new URL(t.url),e);if(["ws:","wss:"].includes(u.url.protocol))return await b(u.url,e);let n=new URL(u.url.toString());return n.protocol=u.url.protocol==="https:"?"wss:":"ws:",n.pathname="/websocket",await b(n,e)},k=()=>{r=null,h=g()};function E(){t.reconnect&&!a&&S<t.reconnect.retries?(a=!0,setTimeout(()=>{S+=1,this.connect().then(()=>{S=0,a=!1}).catch(()=>{})},Math.max(1,t.reconnect.delay))):a=!1}let l={open:new Set([]),error:new Set([]),close:new Set([]),message:new Set([])},C=async(e,n)=>{for(;e.readyState!==WebSocket.CLOSED;){let o=await y(e).catch(()=>{});if(o){if("type"in o){if(o.type==="auth"&&f(n)){let i=await n.getToken();if(i){e.send(m({access_token:i}));continue}}if(t.heartbeat&&o.type==="ping"){e.send(w());continue}}l.message.forEach(i=>i.call(e,o))}}};return{async connect(){let e=this,n=await v(e);return new Promise((o,i)=>{let p=!1,c=new globalThis.WebSocket(n);c.addEventListener("open",async s=>{if(t.authMode==="handshake"&&f(e)){let d=await e.getToken();d&&c.send(m({access_token:d}))}p=!0,l.open.forEach(d=>d.call(c,s)),C(c,e),o()}),c.addEventListener("error",s=>{l.error.forEach(d=>d.call(c,s)),k(),E.call(this),p||i(s)}),c.addEventListener("close",s=>{l.close.forEach(d=>d.call(c,s)),k(),E.call(this),p||i(s)}),r=c})},disconnect(){r&&r?.readyState===WebSocket.OPEN&&r.close(),r=null},onWebSocket(e,n){if(e==="message"){let o=function(i){if(typeof i.data!="string")return n.call(this,i);try{return n.call(this,JSON.parse(i.data))}catch{return n.call(this,i)}};return l[e].add(o),()=>l[e].delete(o)}return l[e].add(n),()=>l[e].delete(n)},sendMessage(e){if(!r||r?.readyState!==WebSocket.OPEN)throw new Error("websocket connection not OPEN");if(typeof e=="string"){r.send(e);return}"uid"in e||(e.uid=h.next().value),r?.send(JSON.stringify(e))},async subscribe(e,n={}){(!r||r.readyState!==WebSocket.OPEN)&&await this.connect(),"uid"in n||(n.uid=h.next().value);let o=!0,i=r,p=s=>i.send(JSON.stringify(s));p({...n,collection:e,type:"subscribe"});async function*c(){for(;o&&r&&r.readyState===WebSocket.OPEN;){let s=await y(r).catch(()=>{});if(s){if("type"in s&&"status"in s&&s.type==="subscribe"&&s.status==="error")throw s;"type"in s&&"uid"in s&&s.type==="subscription"&&s.uid===n.uid&&(yield s)}}if(t.reconnect&&a){for(;a;)await W(10);r&&r.readyState===WebSocket.OPEN&&(r.send(JSON.stringify({...n,collection:e,type:"subscribe"})),yield*c())}}return{subscription:c(),unsubscribe(){p({uid:n.uid,type:"unsubscribe"}),o=!1}}}}}}var W=t=>new Promise(u=>setTimeout(()=>u(),t));export{m as a,w as b,y as c,g as d,j as e,W as f};
//# sourceMappingURL=chunk-2VYDJM4Y.js.map