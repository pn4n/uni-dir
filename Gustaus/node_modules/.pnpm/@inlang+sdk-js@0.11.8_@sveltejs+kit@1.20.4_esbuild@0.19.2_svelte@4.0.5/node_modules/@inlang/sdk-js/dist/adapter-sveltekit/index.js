var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/ts-dedent/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/ts-dedent/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dedent = void 0;
    function dedent21(templ) {
      var values = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
      }
      var strings = Array.from(typeof templ === "string" ? [templ] : templ);
      strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
      var indentLengths = strings.reduce(function(arr, str) {
        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
        if (matches) {
          return arr.concat(matches.map(function(match) {
            var _a, _b;
            return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
          }));
        }
        return arr;
      }, []);
      if (indentLengths.length) {
        var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
        strings = strings.map(function(str) {
          return str.replace(pattern_1, "\n");
        });
      }
      strings[0] = strings[0].replace(/^\r?\n/, "");
      var string = strings[0];
      values.forEach(function(value, i) {
        var endentations = string.match(/(?:^|\n)( *)$/);
        var endentation = endentations ? endentations[1] : "";
        var indentedValue = value;
        if (typeof value === "string" && value.includes("\n")) {
          indentedValue = String(value).split("\n").map(function(str, i2) {
            return i2 === 0 ? str : "" + endentation + str;
          }).join("\n");
        }
        string += indentedValue + strings[i + 1];
      });
      return string;
    }
    exports.dedent = dedent21;
    exports.default = dedent21;
  }
});

// ../../node_modules/vitefu/src/sync.cjs
var require_sync = __commonJS({
  "../../node_modules/vitefu/src/sync.cjs"(exports, module) {
    function isDepIncluded2(dep, optimizeDepsInclude) {
      return optimizeDepsInclude.some((id) => parseIncludeStr(id) === dep);
    }
    function isDepExcluded2(dep, optimizeDepsExclude) {
      dep = parseIncludeStr(dep);
      return optimizeDepsExclude.some(
        (id) => id === dep || dep.startsWith(`${id}/`)
      );
    }
    function isDepNoExternaled2(dep, ssrNoExternal) {
      if (ssrNoExternal === true) {
        return true;
      } else {
        return isMatch(dep, ssrNoExternal);
      }
    }
    function isDepExternaled2(dep, ssrExternal) {
      return ssrExternal.includes(dep);
    }
    function parseIncludeStr(raw) {
      const lastArrow = raw.lastIndexOf(">");
      return lastArrow === -1 ? raw : raw.slice(lastArrow + 1).trim();
    }
    function isMatch(target, pattern) {
      if (Array.isArray(pattern)) {
        return pattern.some((p2) => isMatch(target, p2));
      } else if (typeof pattern === "string") {
        return target === pattern;
      } else if (pattern instanceof RegExp) {
        return pattern.test(target);
      }
    }
    module.exports = {
      isDepIncluded: isDepIncluded2,
      isDepExcluded: isDepExcluded2,
      isDepNoExternaled: isDepNoExternaled2,
      isDepExternaled: isDepExternaled2
    };
  }
});

// src/adapter-sveltekit/vite-plugin/plugin.ts
var import_ts_dedent20 = __toESM(require_dist(), 1);

// src/adapter-sveltekit/vite-plugin/checks/appTemplate.ts
import { readFile, writeFile } from "node:fs/promises";
var assertAppTemplateIsCorrect = async ({ svelteKit: svelteKit2, cwdFolderPath: cwdFolderPath2 }) => {
  const appTemplatePath = svelteKit2.files.appTemplate;
  const markup = await readFile(appTemplatePath, { encoding: "utf-8" });
  const updatedMarkup = removeHtmlLangAttribute(markup);
  if (!updatedMarkup)
    return;
  console.info(
    `Updating '${appTemplatePath.replace(
      cwdFolderPath2,
      ""
    )}' to remove the 'lang' attribute from the <html> tag.`
  );
  await writeFile(appTemplatePath, updatedMarkup, { encoding: "utf-8" });
};
var REGEX_LANG_ATTRIBUTE = /<html[^>]*(\slang="[^"]*")[^>]*>/;
var removeHtmlLangAttribute = (markup) => {
  const execArray = REGEX_LANG_ATTRIBUTE.exec(markup);
  if (!execArray)
    return;
  const htmlTag = execArray[0];
  const langAttribute = execArray[1];
  const index = execArray.index;
  return markup.slice(0, index) + htmlTag.replace(langAttribute, "") + markup.slice(index + htmlTag.length);
};

// src/adapter-sveltekit/vite-plugin/checks/routes.ts
var import_ts_dedent10 = __toESM(require_dist(), 1);
import { mkdir as mkdir2, writeFile as writeFile3 } from "node:fs/promises";
import path3, { dirname } from "node:path";

// src/adapter-sveltekit/vite-plugin/config.ts
import { mkdir, readFile as readFile2, writeFile as writeFile2, stat } from "node:fs/promises";

// ../core/dist/plugin/errors/PluginSetupError.js
var _PluginSetupError_id;
var PluginSetupError = class extends Error {
  constructor() {
    super(...arguments);
    _PluginSetupError_id.set(this, "PluginSetupError");
  }
};
_PluginSetupError_id = /* @__PURE__ */ new WeakMap();

// ../../node_modules/deepmerge-ts/dist/node/index.mjs
var actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
var actionsInto = {
  defaultMerge: actions.defaultMerge
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
var validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords(m_target, values, utils, meta) {
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyTarget = { value: propValues[0] };
    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);
    if (key === "__proto__") {
      Object.defineProperty(m_target, key, {
        value: propertyTarget.value,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      m_target.value[key] = propertyTarget.value;
    }
  }
}
function mergeArrays(m_target, values) {
  m_target.value.push(...values.slice(1).flat());
}
function mergeSets(m_target, values) {
  for (const value of getIterableOfIterables(values.slice(1))) {
    m_target.value.add(value);
  }
}
function mergeMaps(m_target, values) {
  for (const [key, value] of getIterableOfIterables(values.slice(1))) {
    m_target.value.set(key, value);
  }
}
function mergeOthers(m_target, values) {
  m_target.value = values.at(-1);
}
var defaultMergeIntoFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeArrays,
  mergeMaps,
  mergeOthers,
  mergeRecords,
  mergeSets
});
function deepmergeInto(target, ...objects) {
  return void deepmergeIntoCustom({})(target, ...objects);
}
function deepmergeIntoCustom(options, rootMetaData) {
  const utils = getIntoUtils(options, customizedDeepmergeInto);
  function customizedDeepmergeInto(target, ...objects) {
    mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);
  }
  return customizedDeepmergeInto;
}
function getIntoUtils(options, customizedDeepmergeInto) {
  return {
    defaultMergeFunctions: defaultMergeIntoFunctions,
    mergeFunctions: {
      ...defaultMergeIntoFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeIntoFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers] : [key, option]))
    },
    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,
    deepmergeInto: customizedDeepmergeInto,
    actions: actionsInto
  };
}
function mergeUnknownsInto(m_target, values, utils, meta) {
  if (values.length === 0) {
    return;
  }
  if (values.length === 1) {
    return void mergeOthersInto(m_target, values, utils, meta);
  }
  const type = getObjectType(m_target.value);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return void mergeRecordsInto(m_target, values, utils, meta);
    }
    case 2: {
      return void mergeArraysInto(m_target, values, utils, meta);
    }
    case 3: {
      return void mergeSetsInto(m_target, values, utils, meta);
    }
    case 4: {
      return void mergeMapsInto(m_target, values, utils, meta);
    }
    default: {
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
}
function mergeRecordsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);
  }
}
function mergeArraysInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeArrays(m_target, values);
  }
}
function mergeSetsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeSets(m_target, values);
  }
}
function mergeMapsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeMaps(m_target, values);
  }
}
function mergeOthersInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeOthers(m_target, values);
  }
}

// ../core/dist/plugin/setupPlugins.js
var import_ts_dedent = __toESM(require_dist(), 1);
async function setupPlugins(args) {
  if (args.config.plugins === void 0) {
    args.config.plugins = [];
    return [args.config];
  }
  const mergedConfig = { ...args.config };
  const errors = [];
  for (let i = 0; i < args.config.plugins.length; i++) {
    try {
      if (typeof args.config.plugins[i] === "function") {
        args.config.plugins[i] = args.config.plugins[i](args.env);
      }
      const plugin2 = args.config.plugins[i];
      const config = await plugin2?.config({ ...mergedConfig });
      deepmergeInto(mergedConfig, config);
    } catch (error) {
      if (!error || typeof error !== "object" || !("message" in error)) {
        errors.push(new PluginSetupError("" + error));
        continue;
      }
      const id = args.config.plugins[i]?.id;
      if (!id) {
        errors.push(new PluginSetupError(import_ts_dedent.dedent`
					Failed to setup a plugin:

					${error?.message ?? "Unknown error"}

					It seems a plugin was configured incorrectly.
					Try to change 'plugin' to 'plugin()' or consult the documentation of that plugin.
				`));
      } else {
        errors.push(new PluginSetupError(import_ts_dedent.dedent`
					Failed to setup plugin '${id}':

					${error?.message ?? "Unknown error"}
				`));
      }
    }
  }
  mergedConfig.languages = [...new Set(mergedConfig.languages)];
  return [mergedConfig, errors.length > 0 ? errors : void 0];
}

// ../core/dist/config/setupConfig.js
var import_ts_dedent3 = __toESM(require_dist(), 1);

// ../../node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path5, errorMaps, issueData } = params;
  const fullPath = [...path5, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path5, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path5;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b2) {
  const aType = getParsedType(a);
  const bType = getParsedType(b2);
  if (a === b2) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b2) {
    return new _ZodPipeline({
      in: a,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../core/dist/ast/zod.js
var Node = z.object({
  type: z.string(),
  metadata: z.any().optional()
});
var Identifier = Node.extend({
  type: z.literal("Identifier"),
  name: z.string()
});
var LanguageTag = Node.extend({
  type: z.literal("LanguageTag"),
  name: z.string()
});
var Text = Node.extend({
  type: z.literal("Text"),
  value: z.string()
});
var VariableReference = Node.extend({
  type: z.literal("VariableReference"),
  name: z.string()
});
var Placeholder = Node.extend({
  type: z.literal("Placeholder"),
  body: VariableReference
});
var Pattern = Node.extend({
  type: z.literal("Pattern"),
  elements: z.array(Text.or(Placeholder))
});
var Message = Node.extend({
  type: z.literal("Message"),
  id: Identifier,
  pattern: Pattern
});
var Resource = Node.extend({
  type: z.literal("Resource"),
  languageTag: LanguageTag,
  body: z.array(Message)
});

// ../core/dist/config/parseConfig.js
var import_ts_dedent2 = __toESM(require_dist(), 1);

// ../core/dist/config/ideExtension/zodSchema.js
var documentSelectorSchema = arrayType(objectType({
  language: stringType().optional(),
  scheme: stringType().optional(),
  pattern: stringType().optional(),
  notebookType: stringType().optional()
})).optional();
var positionSchema = objectType({
  start: objectType({
    line: numberType(),
    character: numberType()
  }),
  end: objectType({
    line: numberType(),
    character: numberType()
  })
});
var messageReferenceSchema = objectType({
  messageId: stringType(),
  position: positionSchema
});
var zodIdeExtensionConfigSchema = objectType({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: arrayType(functionType().args(objectType({ documentText: stringType() })).returns(promiseType(arrayType(messageReferenceSchema)))).optional(),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: arrayType(objectType({
    /**
     * Function which is called, when the user finished the message extraction command.
     *
     * @param messageId is the message identifier entered by the user
     * @param selection is the text which was extracted
     * @returns the code which is inserted into the document
     */
    callback: functionType().args(stringType(), stringType()).returns(stringType())
  })).optional(),
  /**
   * An array of VSCode DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: documentSelectorSchema
});

// ../core/dist/config/zod.js
var zConfig = z.object({
  referenceLanguage: z.string().transform((value) => value),
  languages: z.array(z.string()).refine((items) => new Set(items).size === items.length, {
    message: "Languages contains duplicates. The provided languages must be unique."
  }),
  lint: z.object({
    rules: z.array(z.any())
  }).optional(),
  readResources: z.function().args(z.any()).returns(z.promise(z.array(Resource))),
  writeResources: z.function().args(z.any()).returns(z.promise(z.void())),
  ideExtension: zodIdeExtensionConfigSchema.optional(),
  plugins: z.union([z.undefined(), z.array(z.object({ id: z.string(), config: z.function() }))])
  // TODO define lint and experimental
});

// ../core/dist/config/parseConfig.js
var _ParseConfigException_id;
var ParseConfigException = class extends Error {
  constructor() {
    super(...arguments);
    _ParseConfigException_id.set(this, "ParseConfigException");
  }
};
_ParseConfigException_id = /* @__PURE__ */ new WeakMap();
async function parseConfig(args) {
  try {
    hasSetupAResourcePlugin(args.config);
    const parsedConfig = zConfig.passthrough().parse(args.config);
    referenceLanguageMustBeInLanguages(args.config);
    const resources = await args.config.readResources({ config: args.config });
    validateResources(resources);
    await languagesMatch(args.config, resources);
    await roundtripTest(args.config, resources);
    return [parsedConfig, void 0];
  } catch (error) {
    return [void 0, error];
  }
}
function hasSetupAResourcePlugin(config) {
  if (!config.readResources || !config.writeResources) {
    throw new ParseConfigException(`It seems you didn't set up a plugin to handle Resource files. See https://inlang.com/documentation/plugins/registry.`);
  }
}
function referenceLanguageMustBeInLanguages(config) {
  if (!config.languages.includes(config.referenceLanguage)) {
    throw new ParseConfigException(`The reference language "${config.referenceLanguage}" must be included in the list of languages.`);
  }
}
function validateResources(resources) {
  for (const resource of resources) {
    Resource.parse(resource);
  }
}
async function languagesMatch(config, resources) {
  const languages = resources.map((resource) => resource.languageTag.name);
  const areEqual = languages.sort().join(",") === config.languages.sort().join(",");
  if (areEqual === false) {
    throw new ParseConfigException(`The list of languages in the config file does not match the returned resources from \`readResources()\`.`);
  }
}
async function roundtripTest(config, initialResources) {
  const commonErrorMessage = "A roundtrip test of the readResources and writeResources functions failed:\n";
  await config.writeResources({ config, resources: initialResources });
  const readResourcesAgain = await config.readResources({ config });
  if (initialResources.length !== readResourcesAgain.length) {
    throw new ParseConfigException(commonErrorMessage + "The number of resources don't match.");
  }
  for (const intialResource of initialResources) {
    const matchingReadResourceAgain = readResourcesAgain.find((readResourceAgain) => readResourceAgain.languageTag.name === intialResource.languageTag.name);
    if (matchingReadResourceAgain === void 0) {
      throw new ParseConfigException(commonErrorMessage + `Missing the resource "${intialResource.languageTag.name}"`);
    }
    for (const [messageIndex, initialMessage] of intialResource.body.entries()) {
      if (JSON.stringify(initialMessage) !== JSON.stringify(matchingReadResourceAgain.body[messageIndex]))
        throw new ParseConfigException((0, import_ts_dedent2.dedent)(`
${commonErrorMessage}
The message with id "${initialMessage.id.name}" does not match for the resource
with languageTag.name "${intialResource.languageTag.name}".

Received:
${JSON.stringify(matchingReadResourceAgain.body[messageIndex], void 0, 2)}

Expected:
${JSON.stringify(initialMessage, void 0, 2)}
`));
    }
  }
}

// ../core/dist/config/setupConfig.js
async function setupConfig(args) {
  if (args.module.defineConfig === void 0) {
    throw new Error(`The "defineConfig" function is missing from the "inlang.config.js" file.`);
  }
  let config = await args.module.defineConfig(args.env);
  const [configWithPlugins, pluginErrors] = await setupPlugins({ config, env: args.env });
  config = configWithPlugins;
  const [parsedConfig, testConfigException] = await parseConfig({ config });
  if (testConfigException) {
    throw new Error(import_ts_dedent3.dedent`
			The inlang.config.js is invalid.

			# The following errors occurred during the setup of plugins:

			${pluginErrors ? pluginErrors.map((e) => e.message).join("\n") : "None \u2705"}

			# The following errors occurred during the validation of the config:

			${formatErrors(testConfigException)}

			---

			If plugins return errors, chances are high that the plugin errors are the root cause
			for the config errors. Try to fix the plugin errors first.

		`);
  }
  if (pluginErrors) {
    for (const e of pluginErrors)
      console.error(e);
  }
  return parsedConfig;
}
var formatErrors = (error) => {
  if (error instanceof ZodError) {
    return error.errors.map((e) => `[${e.path}] ${e.message}`).join("\n");
  }
  return error.message;
};

// ../core/dist/environment/$import.js
var import_ts_dedent4 = __toESM(require_dist(), 1);

// ../../source-code-git/fs/dist/utilities/normalizePath.js
function normalizePath(path5) {
  if (path5 === "\\" || path5 === "/")
    return "/";
  const len = path5.length;
  if (len <= 1)
    return path5;
  let prefix = "";
  if (len > 4 && path5[3] === "\\") {
    const ch = path5[2];
    if ((ch === "?" || ch === ".") && path5.slice(0, 2) === "\\\\") {
      path5 = path5.slice(2);
      prefix = "//";
    }
  }
  const segs = path5.split(/[/\\]+/);
  return prefix + segs.join("/");
}

// ../core/dist/environment/$import.js
function initialize$import(args) {
  return (uri) => $import(uri, args);
}
var $ImportError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "$ImportError";
  }
};
async function $import(uri, environment) {
  const _fetch = environment.fetch;
  const moduleAsText = uri.startsWith("http") ? await (await _fetch(uri)).text() : await environment.fs.readFile(normalizePath(uri), { encoding: "utf-8" });
  const moduleWithMimeType = "data:application/javascript," + encodeURIComponent(moduleAsText);
  try {
    return await import(
      /* @vite-ignore */
      moduleWithMimeType
    );
  } catch (error) {
    let message = `Error while importing ${uri}: ${error?.message ?? "Unknown error"}`;
    if (error instanceof SyntaxError && uri.includes("jsdelivr")) {
      message += import_ts_dedent4.dedent`\n\n
Are you sure that the file exists on JSDelivr?

The error indicates that the imported file does not exist on JSDelivr. For non-existent files, JSDelivr returns a 404 text that JS cannot parse as a module and throws a SyntaxError.
			`;
    }
    throw new $ImportError(message);
  }
}

// src/config/config.ts
var import_ts_dedent5 = __toESM(require_dist(), 1);

// src/exceptions.ts
var InlangException = class extends Error {
};

// src/adapter-sveltekit/vite-plugin/exceptions.ts
var InlangSdkException = class extends InlangException {
  constructor(message, cause) {
    super();
    this.cause = cause;
    this.message = `

--------------------------------------------------------------------------------

[${this.constructor.name}]

${message}

--------------------------------------------------------------------------------

Cause:
`;
  }
};

// src/config/config.ts
var initInlangEnvironment = async () => {
  const fs2 = await import("node:fs/promises").catch(
    () => new Proxy({}, {
      get: (target, key) => {
        if (key === "then")
          return Promise.resolve(target);
        return () => {
          throw new InlangSdkException(
            "`node:fs/promises` is not available in the current environment"
          );
        };
      }
    })
  );
  return {
    $fs: fs2,
    $import: initialize$import({
      fs: fs2,
      fetch: async (...args) => await fetch(...args).catch((error) => {
        if (error instanceof TypeError && error.cause?.code === "UND_ERR_CONNECT_TIMEOUT") {
          throw new InlangSdkException(
            import_ts_dedent5.dedent`
								Node.js failed to resolve the URL. This can happen sometimes during development.
								Usually restarting the server helps.
							`,
            error
          );
        }
        throw new InlangSdkException(`Failed to fetch from (${args[0]})`, error);
      })
    })
  };
};
var initConfig = async (module) => {
  if (!module) {
    throw new InlangSdkException("could not read `inlang.config.js`");
  }
  const env = await initInlangEnvironment();
  return setupConfig({ module, env });
};

// src/adapter-sveltekit/vite-plugin/config.ts
var import_ts_dedent9 = __toESM(require_dist(), 1);

// ../core/dist/test/testConfig.js
var _TestConfigException_id;
_TestConfigException_id = /* @__PURE__ */ new WeakMap();

// ../core/dist/test/testConfigFile.js
async function testConfigFile(args) {
  try {
    const [, importKeywordUsedException] = importKeywordUsed(args.file);
    if (importKeywordUsedException) {
      return [void 0, importKeywordUsedException];
    }
    const module = await import("data:application/javascript;base64," + btoa(args.file));
    const config = await setupConfig({ module, env: args.env });
    const [, exception] = await parseConfig({ config });
    if (exception) {
      return [void 0, exception];
    }
    return [true, void 0];
  } catch (e) {
    return [void 0, new ParseConfigException(e.message)];
  }
}
function importKeywordUsed(configFile) {
  const regex = /(?<!(\$)|\{|\{\s|\{\s\s)import\b/;
  const hasError = regex.test(configFile);
  if (hasError) {
    return [
      void 0,
      new ParseConfigException("Regular import statements are not allowed inside `inlang.config.js`. Use `$import` of the inlang environment instead. See https://inlang.com/documentation/inlang-environment.")
    ];
  }
  return [true, void 0];
}

// ../core/dist/test/mockEnvironment.js
var import_ts_dedent6 = __toESM(require_dist(), 1);

// ../sdk-js-plugin/dist/index.js
var _;
(function(s) {
  s.assertEqual = (r) => r;
  function e(r) {
  }
  s.assertIs = e;
  function t(r) {
    throw new Error();
  }
  s.assertNever = t, s.arrayToEnum = (r) => {
    let a = {};
    for (let i of r)
      a[i] = i;
    return a;
  }, s.getValidEnumValues = (r) => {
    let a = s.objectKeys(r).filter((o) => typeof r[r[o]] != "number"), i = {};
    for (let o of a)
      i[o] = r[o];
    return s.objectValues(i);
  }, s.objectValues = (r) => s.objectKeys(r).map(function(a) {
    return r[a];
  }), s.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    let a = [];
    for (let i in r)
      Object.prototype.hasOwnProperty.call(r, i) && a.push(i);
    return a;
  }, s.find = (r, a) => {
    for (let i of r)
      if (a(i))
        return i;
  }, s.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function n2(r, a = " | ") {
    return r.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  s.joinValues = n2, s.jsonStringifyReplacer = (r, a) => typeof a == "bigint" ? a.toString() : a;
})(_ || (_ = {}));
var Te;
(function(s) {
  s.mergeShapes = (e, t) => ({ ...e, ...t });
})(Te || (Te = {}));
var d = _.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var $ = (s) => {
  switch (typeof s) {
    case "undefined":
      return d.undefined;
    case "string":
      return d.string;
    case "number":
      return isNaN(s) ? d.nan : d.number;
    case "boolean":
      return d.boolean;
    case "function":
      return d.function;
    case "bigint":
      return d.bigint;
    case "symbol":
      return d.symbol;
    case "object":
      return Array.isArray(s) ? d.array : s === null ? d.null : s.then && typeof s.then == "function" && s.catch && typeof s.catch == "function" ? d.promise : typeof Map < "u" && s instanceof Map ? d.map : typeof Set < "u" && s instanceof Set ? d.set : typeof Date < "u" && s instanceof Date ? d.date : d.object;
    default:
      return d.unknown;
  }
};
var c = _.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var S = class extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n2) => {
      this.issues = [...this.issues, n2];
    }, this.addIssues = (n2 = []) => {
      this.issues = [...this.issues, ...n2];
    };
    let t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    let t = e || function(a) {
      return a.message;
    }, n2 = { _errors: [] }, r = (a) => {
      for (let i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(r);
        else if (i.code === "invalid_return_type")
          r(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          r(i.argumentsError);
        else if (i.path.length === 0)
          n2._errors.push(t(i));
        else {
          let o = n2, f = 0;
          for (; f < i.path.length; ) {
            let l = i.path[f];
            f === i.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(t(i))) : o[l] = o[l] || { _errors: [] }, o = o[l], f++;
          }
        }
    };
    return r(this), n2;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, _.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    let t = {}, n2 = [];
    for (let r of this.issues)
      r.path.length > 0 ? (t[r.path[0]] = t[r.path[0]] || [], t[r.path[0]].push(e(r))) : n2.push(e(r));
    return { formErrors: n2, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
};
S.create = (s) => new S(s);
var le = (s, e) => {
  let t;
  switch (s.code) {
    case c.invalid_type:
      s.received === d.undefined ? t = "Required" : t = `Expected ${s.expected}, received ${s.received}`;
      break;
    case c.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(s.expected, _.jsonStringifyReplacer)}`;
      break;
    case c.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${_.joinValues(s.keys, ", ")}`;
      break;
    case c.invalid_union:
      t = "Invalid input";
      break;
    case c.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${_.joinValues(s.options)}`;
      break;
    case c.invalid_enum_value:
      t = `Invalid enum value. Expected ${_.joinValues(s.options)}, received '${s.received}'`;
      break;
    case c.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case c.invalid_return_type:
      t = "Invalid function return type";
      break;
    case c.invalid_date:
      t = "Invalid date";
      break;
    case c.invalid_string:
      typeof s.validation == "object" ? "includes" in s.validation ? (t = `Invalid input: must include "${s.validation.includes}"`, typeof s.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${s.validation.position}`)) : "startsWith" in s.validation ? t = `Invalid input: must start with "${s.validation.startsWith}"` : "endsWith" in s.validation ? t = `Invalid input: must end with "${s.validation.endsWith}"` : _.assertNever(s.validation) : s.validation !== "regex" ? t = `Invalid ${s.validation}` : t = "Invalid";
      break;
    case c.too_small:
      s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "more than"} ${s.minimum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "over"} ${s.minimum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${s.minimum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(s.minimum))}` : t = "Invalid input";
      break;
    case c.too_big:
      s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "less than"} ${s.maximum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "under"} ${s.maximum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "bigint" ? t = `BigInt must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly" : s.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(s.maximum))}` : t = "Invalid input";
      break;
    case c.custom:
      t = "Invalid input";
      break;
    case c.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case c.not_multiple_of:
      t = `Number must be a multiple of ${s.multipleOf}`;
      break;
    case c.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, _.assertNever(s);
  }
  return { message: t };
};
var je = le;
function pe() {
  return je;
}
var me = (s) => {
  let { data: e, path: t, errorMaps: n2, issueData: r } = s, a = [...t, ...r.path || []], i = { ...r, path: a }, o = "", f = n2.filter((l) => !!l).slice().reverse();
  for (let l of f)
    o = l(i, { data: e, defaultError: o }).message;
  return { ...r, path: a, message: r.message || o };
};
function u(s, e) {
  let t = me({ issueData: e, data: s.data, path: s.path, errorMaps: [s.common.contextualErrorMap, s.schemaErrorMap, pe(), le].filter((n2) => !!n2) });
  s.common.issues.push(t);
}
var k = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    let n2 = [];
    for (let r of t) {
      if (r.status === "aborted")
        return m;
      r.status === "dirty" && e.dirty(), n2.push(r.value);
    }
    return { status: e.value, value: n2 };
  }
  static async mergeObjectAsync(e, t) {
    let n2 = [];
    for (let r of t)
      n2.push({ key: await r.key, value: await r.value });
    return k.mergeObjectSync(e, n2);
  }
  static mergeObjectSync(e, t) {
    let n2 = {};
    for (let r of t) {
      let { key: a, value: i } = r;
      if (a.status === "aborted" || i.status === "aborted")
        return m;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), (typeof i.value < "u" || r.alwaysSet) && (n2[a.value] = i.value);
    }
    return { status: e.value, value: n2 };
  }
};
var m = Object.freeze({ status: "aborted" });
var Re = (s) => ({ status: "dirty", value: s });
var b = (s) => ({ status: "valid", value: s });
var Se = (s) => s.status === "aborted";
var Ce = (s) => s.status === "dirty";
var ge = (s) => s.status === "valid";
var ye = (s) => typeof Promise < "u" && s instanceof Promise;
var h;
(function(s) {
  s.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, s.toString = (e) => typeof e == "string" ? e : e?.message;
})(h || (h = {}));
var N = class {
  constructor(e, t, n2, r) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n2, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var Ne = (s, e) => {
  if (ge(e))
    return { success: true, data: e.value };
  if (!s.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: false, get error() {
    if (this._error)
      return this._error;
    let t = new S(s.common.issues);
    return this._error = t, this._error;
  } };
};
function g(s) {
  if (!s)
    return {};
  let { errorMap: e, invalid_type_error: t, required_error: n2, description: r } = s;
  if (e && (t || n2))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: r } : { errorMap: (i, o) => i.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n2 ?? o.defaultError } : { message: t ?? o.defaultError }, description: r };
}
var v = class {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return $(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || { common: e.parent.common, data: e.data, parsedType: $(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent };
  }
  _processInputParams(e) {
    return { status: new k(), ctx: { common: e.parent.common, data: e.data, parsedType: $(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } };
  }
  _parseSync(e) {
    let t = this._parse(e);
    if (ye(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    let t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    let n2 = this.safeParse(e, t);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(e, t) {
    var n2;
    let r = { common: { issues: [], async: (n2 = t?.async) !== null && n2 !== void 0 ? n2 : false, contextualErrorMap: t?.errorMap }, path: t?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: $(e) }, a = this._parseSync({ data: e, path: r.path, parent: r });
    return Ne(r, a);
  }
  async parseAsync(e, t) {
    let n2 = await this.safeParseAsync(e, t);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(e, t) {
    let n2 = { common: { issues: [], contextualErrorMap: t?.errorMap, async: true }, path: t?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: $(e) }, r = this._parse({ data: e, path: n2.path, parent: n2 }), a = await (ye(r) ? r : Promise.resolve(r));
    return Ne(n2, a);
  }
  refine(e, t) {
    let n2 = (r) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(r) : t;
    return this._refinement((r, a) => {
      let i = e(r), o = () => a.addIssue({ code: c.custom, ...n2(r) });
      return typeof Promise < "u" && i instanceof Promise ? i.then((f) => f ? true : (o(), false)) : i ? true : (o(), false);
    });
  }
  refinement(e, t) {
    return this._refinement((n2, r) => e(n2) ? true : (r.addIssue(typeof t == "function" ? t(n2, r) : t), false));
  }
  _refinement(e) {
    return new I({ schema: this, typeName: p.ZodEffects, effect: { type: "refinement", refinement: e } });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return j.create(this, this._def);
  }
  nullable() {
    return V.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return C.create(this, this._def);
  }
  promise() {
    return U.create(this, this._def);
  }
  or(e) {
    return Y.create([this, e], this._def);
  }
  and(e) {
    return H.create(this, e, this._def);
  }
  transform(e) {
    return new I({ ...g(this._def), schema: this, typeName: p.ZodEffects, effect: { type: "transform", transform: e } });
  }
  default(e) {
    let t = typeof e == "function" ? e : () => e;
    return new F({ ...g(this._def), innerType: this, defaultValue: t, typeName: p.ZodDefault });
  }
  brand() {
    return new _e({ typeName: p.ZodBranded, type: this, ...g(this._def) });
  }
  catch(e) {
    let t = typeof e == "function" ? e : () => e;
    return new ce({ ...g(this._def), innerType: this, catchValue: t, typeName: p.ZodCatch });
  }
  describe(e) {
    let t = this.constructor;
    return new t({ ...this._def, description: e });
  }
  pipe(e) {
    return ee.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var Ae = /^c[^\s-]{8,}$/i;
var Ze = /^[a-z][a-z0-9]*$/;
var Me = /[0-9A-HJKMNP-TV-Z]{26}/;
var Pe = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var ze = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var Ve = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var $e = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var Le = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var De = (s) => s.precision ? s.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}Z$`) : s.precision === 0 ? s.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : s.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Ue(s, e) {
  return !!((e === "v4" || !e) && $e.test(s) || (e === "v6" || !e) && Le.test(s));
}
var O = class extends v {
  constructor() {
    super(...arguments), this._regex = (e, t, n2) => this.refinement((r) => e.test(r), { validation: t, code: c.invalid_string, ...h.errToObj(n2) }), this.nonempty = (e) => this.min(1, h.errToObj(e)), this.trim = () => new O({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }), this.toLowerCase = () => new O({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }), this.toUpperCase = () => new O({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== d.string) {
      let a = this._getOrReturnCtx(e);
      return u(a, { code: c.invalid_type, expected: d.string, received: a.parsedType }), m;
    }
    let n2 = new k(), r;
    for (let a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (r = this._getOrReturnCtx(e, r), u(r, { code: c.too_small, minimum: a.value, type: "string", inclusive: true, exact: false, message: a.message }), n2.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (r = this._getOrReturnCtx(e, r), u(r, { code: c.too_big, maximum: a.value, type: "string", inclusive: true, exact: false, message: a.message }), n2.dirty());
      else if (a.kind === "length") {
        let i = e.data.length > a.value, o = e.data.length < a.value;
        (i || o) && (r = this._getOrReturnCtx(e, r), i ? u(r, { code: c.too_big, maximum: a.value, type: "string", inclusive: true, exact: true, message: a.message }) : o && u(r, { code: c.too_small, minimum: a.value, type: "string", inclusive: true, exact: true, message: a.message }), n2.dirty());
      } else if (a.kind === "email")
        ze.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "email", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "emoji")
        Ve.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "emoji", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "uuid")
        Pe.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "uuid", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "cuid")
        Ae.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "cuid", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "cuid2")
        Ze.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "cuid2", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "ulid")
        Me.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "ulid", code: c.invalid_string, message: a.message }), n2.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          r = this._getOrReturnCtx(e, r), u(r, { validation: "url", code: c.invalid_string, message: a.message }), n2.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "regex", code: c.invalid_string, message: a.message }), n2.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (r = this._getOrReturnCtx(e, r), u(r, { code: c.invalid_string, validation: { includes: a.value, position: a.position }, message: a.message }), n2.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (r = this._getOrReturnCtx(e, r), u(r, { code: c.invalid_string, validation: { startsWith: a.value }, message: a.message }), n2.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (r = this._getOrReturnCtx(e, r), u(r, { code: c.invalid_string, validation: { endsWith: a.value }, message: a.message }), n2.dirty()) : a.kind === "datetime" ? De(a).test(e.data) || (r = this._getOrReturnCtx(e, r), u(r, { code: c.invalid_string, validation: "datetime", message: a.message }), n2.dirty()) : a.kind === "ip" ? Ue(e.data, a.version) || (r = this._getOrReturnCtx(e, r), u(r, { validation: "ip", code: c.invalid_string, message: a.message }), n2.dirty()) : _.assertNever(a);
    return { status: n2.value, value: e.data };
  }
  _addCheck(e) {
    return new O({ ...this._def, checks: [...this._def.checks, e] });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...h.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...h.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...h.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...h.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...h.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...h.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...h.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...h.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: false, message: e }) : this._addCheck({ kind: "datetime", precision: typeof e?.precision > "u" ? null : e?.precision, offset: (t = e?.offset) !== null && t !== void 0 ? t : false, ...h.errToObj(e?.message) });
  }
  regex(e, t) {
    return this._addCheck({ kind: "regex", regex: e, ...h.errToObj(t) });
  }
  includes(e, t) {
    return this._addCheck({ kind: "includes", value: e, position: t?.position, ...h.errToObj(t?.message) });
  }
  startsWith(e, t) {
    return this._addCheck({ kind: "startsWith", value: e, ...h.errToObj(t) });
  }
  endsWith(e, t) {
    return this._addCheck({ kind: "endsWith", value: e, ...h.errToObj(t) });
  }
  min(e, t) {
    return this._addCheck({ kind: "min", value: e, ...h.errToObj(t) });
  }
  max(e, t) {
    return this._addCheck({ kind: "max", value: e, ...h.errToObj(t) });
  }
  length(e, t) {
    return this._addCheck({ kind: "length", value: e, ...h.errToObj(t) });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
O.create = (s) => {
  var e;
  return new O({ checks: [], typeName: p.ZodString, coerce: (e = s?.coerce) !== null && e !== void 0 ? e : false, ...g(s) });
};
function Be(s, e) {
  let t = (s.toString().split(".")[1] || "").length, n2 = (e.toString().split(".")[1] || "").length, r = t > n2 ? t : n2, a = parseInt(s.toFixed(r).replace(".", "")), i = parseInt(e.toFixed(r).replace(".", ""));
  return a % i / Math.pow(10, r);
}
var M = class extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== d.number) {
      let a = this._getOrReturnCtx(e);
      return u(a, { code: c.invalid_type, expected: d.number, received: a.parsedType }), m;
    }
    let n2, r = new k();
    for (let a of this._def.checks)
      a.kind === "int" ? _.isInteger(e.data) || (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.invalid_type, expected: "integer", received: "float", message: a.message }), r.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.too_small, minimum: a.value, type: "number", inclusive: a.inclusive, exact: false, message: a.message }), r.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.too_big, maximum: a.value, type: "number", inclusive: a.inclusive, exact: false, message: a.message }), r.dirty()) : a.kind === "multipleOf" ? Be(e.data, a.value) !== 0 && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.not_multiple_of, multipleOf: a.value, message: a.message }), r.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.not_finite, message: a.message }), r.dirty()) : _.assertNever(a);
    return { status: r.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, true, h.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, false, h.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, true, h.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, false, h.toString(t));
  }
  setLimit(e, t, n2, r) {
    return new M({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n2, message: h.toString(r) }] });
  }
  _addCheck(e) {
    return new M({ ...this._def, checks: [...this._def.checks, e] });
  }
  int(e) {
    return this._addCheck({ kind: "int", message: h.toString(e) });
  }
  positive(e) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: h.toString(e) });
  }
  negative(e) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: h.toString(e) });
  }
  nonpositive(e) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: h.toString(e) });
  }
  nonnegative(e) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: h.toString(e) });
  }
  multipleOf(e, t) {
    return this._addCheck({ kind: "multipleOf", value: e, message: h.toString(t) });
  }
  finite(e) {
    return this._addCheck({ kind: "finite", message: h.toString(e) });
  }
  safe(e) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: h.toString(e) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: h.toString(e) });
  }
  get minValue() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && _.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (let n2 of this._def.checks) {
      if (n2.kind === "finite" || n2.kind === "int" || n2.kind === "multipleOf")
        return true;
      n2.kind === "min" ? (t === null || n2.value > t) && (t = n2.value) : n2.kind === "max" && (e === null || n2.value < e) && (e = n2.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
};
M.create = (s) => new M({ checks: [], typeName: p.ZodNumber, coerce: s?.coerce || false, ...g(s) });
var P = class extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== d.bigint) {
      let a = this._getOrReturnCtx(e);
      return u(a, { code: c.invalid_type, expected: d.bigint, received: a.parsedType }), m;
    }
    let n2, r = new k();
    for (let a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.too_small, type: "bigint", minimum: a.value, inclusive: a.inclusive, message: a.message }), r.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.too_big, type: "bigint", maximum: a.value, inclusive: a.inclusive, message: a.message }), r.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n2 = this._getOrReturnCtx(e, n2), u(n2, { code: c.not_multiple_of, multipleOf: a.value, message: a.message }), r.dirty()) : _.assertNever(a);
    return { status: r.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, true, h.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, false, h.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, true, h.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, false, h.toString(t));
  }
  setLimit(e, t, n2, r) {
    return new P({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n2, message: h.toString(r) }] });
  }
  _addCheck(e) {
    return new P({ ...this._def, checks: [...this._def.checks, e] });
  }
  positive(e) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: h.toString(e) });
  }
  negative(e) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: h.toString(e) });
  }
  nonpositive(e) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: h.toString(e) });
  }
  nonnegative(e) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: h.toString(e) });
  }
  multipleOf(e, t) {
    return this._addCheck({ kind: "multipleOf", value: e, message: h.toString(t) });
  }
  get minValue() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
P.create = (s) => {
  var e;
  return new P({ checks: [], typeName: p.ZodBigInt, coerce: (e = s?.coerce) !== null && e !== void 0 ? e : false, ...g(s) });
};
var se = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== d.boolean) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.boolean, received: n2.parsedType }), m;
    }
    return b(e.data);
  }
};
se.create = (s) => new se({ typeName: p.ZodBoolean, coerce: s?.coerce || false, ...g(s) });
var D = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== d.date) {
      let a = this._getOrReturnCtx(e);
      return u(a, { code: c.invalid_type, expected: d.date, received: a.parsedType }), m;
    }
    if (isNaN(e.data.getTime())) {
      let a = this._getOrReturnCtx(e);
      return u(a, { code: c.invalid_date }), m;
    }
    let n2 = new k(), r;
    for (let a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (r = this._getOrReturnCtx(e, r), u(r, { code: c.too_small, message: a.message, inclusive: true, exact: false, minimum: a.value, type: "date" }), n2.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (r = this._getOrReturnCtx(e, r), u(r, { code: c.too_big, message: a.message, inclusive: true, exact: false, maximum: a.value, type: "date" }), n2.dirty()) : _.assertNever(a);
    return { status: n2.value, value: new Date(e.data.getTime()) };
  }
  _addCheck(e) {
    return new D({ ...this._def, checks: [...this._def.checks, e] });
  }
  min(e, t) {
    return this._addCheck({ kind: "min", value: e.getTime(), message: h.toString(t) });
  }
  max(e, t) {
    return this._addCheck({ kind: "max", value: e.getTime(), message: h.toString(t) });
  }
  get minDate() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (let t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
};
D.create = (s) => new D({ checks: [], coerce: s?.coerce || false, typeName: p.ZodDate, ...g(s) });
var ne = class extends v {
  _parse(e) {
    if (this._getType(e) !== d.symbol) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.symbol, received: n2.parsedType }), m;
    }
    return b(e.data);
  }
};
ne.create = (s) => new ne({ typeName: p.ZodSymbol, ...g(s) });
var q = class extends v {
  _parse(e) {
    if (this._getType(e) !== d.undefined) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.undefined, received: n2.parsedType }), m;
    }
    return b(e.data);
  }
};
q.create = (s) => new q({ typeName: p.ZodUndefined, ...g(s) });
var J = class extends v {
  _parse(e) {
    if (this._getType(e) !== d.null) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.null, received: n2.parsedType }), m;
    }
    return b(e.data);
  }
};
J.create = (s) => new J({ typeName: p.ZodNull, ...g(s) });
var re = class extends v {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return b(e.data);
  }
};
re.create = (s) => new re({ typeName: p.ZodAny, ...g(s) });
var Z = class extends v {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return b(e.data);
  }
};
Z.create = (s) => new Z({ typeName: p.ZodUnknown, ...g(s) });
var R = class extends v {
  _parse(e) {
    let t = this._getOrReturnCtx(e);
    return u(t, { code: c.invalid_type, expected: d.never, received: t.parsedType }), m;
  }
};
R.create = (s) => new R({ typeName: p.ZodNever, ...g(s) });
var ae = class extends v {
  _parse(e) {
    if (this._getType(e) !== d.undefined) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.void, received: n2.parsedType }), m;
    }
    return b(e.data);
  }
};
ae.create = (s) => new ae({ typeName: p.ZodVoid, ...g(s) });
var C = class extends v {
  _parse(e) {
    let { ctx: t, status: n2 } = this._processInputParams(e), r = this._def;
    if (t.parsedType !== d.array)
      return u(t, { code: c.invalid_type, expected: d.array, received: t.parsedType }), m;
    if (r.exactLength !== null) {
      let i = t.data.length > r.exactLength.value, o = t.data.length < r.exactLength.value;
      (i || o) && (u(t, { code: i ? c.too_big : c.too_small, minimum: o ? r.exactLength.value : void 0, maximum: i ? r.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: r.exactLength.message }), n2.dirty());
    }
    if (r.minLength !== null && t.data.length < r.minLength.value && (u(t, { code: c.too_small, minimum: r.minLength.value, type: "array", inclusive: true, exact: false, message: r.minLength.message }), n2.dirty()), r.maxLength !== null && t.data.length > r.maxLength.value && (u(t, { code: c.too_big, maximum: r.maxLength.value, type: "array", inclusive: true, exact: false, message: r.maxLength.message }), n2.dirty()), t.common.async)
      return Promise.all([...t.data].map((i, o) => r.type._parseAsync(new N(t, i, t.path, o)))).then((i) => k.mergeArray(n2, i));
    let a = [...t.data].map((i, o) => r.type._parseSync(new N(t, i, t.path, o)));
    return k.mergeArray(n2, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new C({ ...this._def, minLength: { value: e, message: h.toString(t) } });
  }
  max(e, t) {
    return new C({ ...this._def, maxLength: { value: e, message: h.toString(t) } });
  }
  length(e, t) {
    return new C({ ...this._def, exactLength: { value: e, message: h.toString(t) } });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
C.create = (s, e) => new C({ type: s, minLength: null, maxLength: null, exactLength: null, typeName: p.ZodArray, ...g(e) });
function W(s) {
  if (s instanceof x) {
    let e = {};
    for (let t in s.shape) {
      let n2 = s.shape[t];
      e[t] = j.create(W(n2));
    }
    return new x({ ...s._def, shape: () => e });
  } else
    return s instanceof C ? new C({ ...s._def, type: W(s.element) }) : s instanceof j ? j.create(W(s.unwrap())) : s instanceof V ? V.create(W(s.unwrap())) : s instanceof E ? E.create(s.items.map((e) => W(e))) : s;
}
var x = class extends v {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let e = this._def.shape(), t = _.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== d.object) {
      let l = this._getOrReturnCtx(e);
      return u(l, { code: c.invalid_type, expected: d.object, received: l.parsedType }), m;
    }
    let { status: n2, ctx: r } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof R && this._def.unknownKeys === "strip"))
      for (let l in r.data)
        i.includes(l) || o.push(l);
    let f = [];
    for (let l of i) {
      let y = a[l], B = r.data[l];
      f.push({ key: { status: "valid", value: l }, value: y._parse(new N(r, B, r.path, l)), alwaysSet: l in r.data });
    }
    if (this._def.catchall instanceof R) {
      let l = this._def.unknownKeys;
      if (l === "passthrough")
        for (let y of o)
          f.push({ key: { status: "valid", value: y }, value: { status: "valid", value: r.data[y] } });
      else if (l === "strict")
        o.length > 0 && (u(r, { code: c.unrecognized_keys, keys: o }), n2.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let l = this._def.catchall;
      for (let y of o) {
        let B = r.data[y];
        f.push({ key: { status: "valid", value: y }, value: l._parse(new N(r, B, r.path, y)), alwaysSet: y in r.data });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      let l = [];
      for (let y of f) {
        let B = await y.key;
        l.push({ key: B, value: await y.value, alwaysSet: y.alwaysSet });
      }
      return l;
    }).then((l) => k.mergeObjectSync(n2, l)) : k.mergeObjectSync(n2, f);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return h.errToObj, new x({ ...this._def, unknownKeys: "strict", ...e !== void 0 ? { errorMap: (t, n2) => {
      var r, a, i, o;
      let f = (i = (a = (r = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(r, t, n2).message) !== null && i !== void 0 ? i : n2.defaultError;
      return t.code === "unrecognized_keys" ? { message: (o = h.errToObj(e).message) !== null && o !== void 0 ? o : f } : { message: f };
    } } : {} });
  }
  strip() {
    return new x({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new x({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e) {
    return new x({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) });
  }
  merge(e) {
    return new x({ unknownKeys: e._def.unknownKeys, catchall: e._def.catchall, shape: () => ({ ...this._def.shape(), ...e._def.shape() }), typeName: p.ZodObject });
  }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  catchall(e) {
    return new x({ ...this._def, catchall: e });
  }
  pick(e) {
    let t = {};
    return _.objectKeys(e).forEach((n2) => {
      e[n2] && this.shape[n2] && (t[n2] = this.shape[n2]);
    }), new x({ ...this._def, shape: () => t });
  }
  omit(e) {
    let t = {};
    return _.objectKeys(this.shape).forEach((n2) => {
      e[n2] || (t[n2] = this.shape[n2]);
    }), new x({ ...this._def, shape: () => t });
  }
  deepPartial() {
    return W(this);
  }
  partial(e) {
    let t = {};
    return _.objectKeys(this.shape).forEach((n2) => {
      let r = this.shape[n2];
      e && !e[n2] ? t[n2] = r : t[n2] = r.optional();
    }), new x({ ...this._def, shape: () => t });
  }
  required(e) {
    let t = {};
    return _.objectKeys(this.shape).forEach((n2) => {
      if (e && !e[n2])
        t[n2] = this.shape[n2];
      else {
        let a = this.shape[n2];
        for (; a instanceof j; )
          a = a._def.innerType;
        t[n2] = a;
      }
    }), new x({ ...this._def, shape: () => t });
  }
  keyof() {
    return Oe(_.objectKeys(this.shape));
  }
};
x.create = (s, e) => new x({ shape: () => s, unknownKeys: "strip", catchall: R.create(), typeName: p.ZodObject, ...g(e) });
x.strictCreate = (s, e) => new x({ shape: () => s, unknownKeys: "strict", catchall: R.create(), typeName: p.ZodObject, ...g(e) });
x.lazycreate = (s, e) => new x({ shape: s, unknownKeys: "strip", catchall: R.create(), typeName: p.ZodObject, ...g(e) });
var Y = class extends v {
  _parse(e) {
    let { ctx: t } = this._processInputParams(e), n2 = this._def.options;
    function r(a) {
      for (let o of a)
        if (o.result.status === "valid")
          return o.result;
      for (let o of a)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      let i = a.map((o) => new S(o.ctx.common.issues));
      return u(t, { code: c.invalid_union, unionErrors: i }), m;
    }
    if (t.common.async)
      return Promise.all(n2.map(async (a) => {
        let i = { ...t, common: { ...t.common, issues: [] }, parent: null };
        return { result: await a._parseAsync({ data: t.data, path: t.path, parent: i }), ctx: i };
      })).then(r);
    {
      let a, i = [];
      for (let f of n2) {
        let l = { ...t, common: { ...t.common, issues: [] }, parent: null }, y = f._parseSync({ data: t.data, path: t.path, parent: l });
        if (y.status === "valid")
          return y;
        y.status === "dirty" && !a && (a = { result: y, ctx: l }), l.common.issues.length && i.push(l.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      let o = i.map((f) => new S(f));
      return u(t, { code: c.invalid_union, unionErrors: o }), m;
    }
  }
  get options() {
    return this._def.options;
  }
};
Y.create = (s, e) => new Y({ options: s, typeName: p.ZodUnion, ...g(e) });
var ue = (s) => s instanceof Q ? ue(s.schema) : s instanceof I ? ue(s.innerType()) : s instanceof X ? [s.value] : s instanceof A ? s.options : s instanceof K ? Object.keys(s.enum) : s instanceof F ? ue(s._def.innerType) : s instanceof q ? [void 0] : s instanceof J ? [null] : null;
var ie = class extends v {
  _parse(e) {
    let { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== d.object)
      return u(t, { code: c.invalid_type, expected: d.object, received: t.parsedType }), m;
    let n2 = this.discriminator, r = t.data[n2], a = this.optionsMap.get(r);
    return a ? t.common.async ? a._parseAsync({ data: t.data, path: t.path, parent: t }) : a._parseSync({ data: t.data, path: t.path, parent: t }) : (u(t, { code: c.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n2] }), m);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, t, n2) {
    let r = /* @__PURE__ */ new Map();
    for (let a of t) {
      let i = ue(a.shape[e]);
      if (!i)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (let o of i) {
        if (r.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        r.set(o, a);
      }
    }
    return new ie({ typeName: p.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: r, ...g(n2) });
  }
};
function ve(s, e) {
  let t = $(s), n2 = $(e);
  if (s === e)
    return { valid: true, data: s };
  if (t === d.object && n2 === d.object) {
    let r = _.objectKeys(e), a = _.objectKeys(s).filter((o) => r.indexOf(o) !== -1), i = { ...s, ...e };
    for (let o of a) {
      let f = ve(s[o], e[o]);
      if (!f.valid)
        return { valid: false };
      i[o] = f.data;
    }
    return { valid: true, data: i };
  } else if (t === d.array && n2 === d.array) {
    if (s.length !== e.length)
      return { valid: false };
    let r = [];
    for (let a = 0; a < s.length; a++) {
      let i = s[a], o = e[a], f = ve(i, o);
      if (!f.valid)
        return { valid: false };
      r.push(f.data);
    }
    return { valid: true, data: r };
  } else
    return t === d.date && n2 === d.date && +s == +e ? { valid: true, data: s } : { valid: false };
}
var H = class extends v {
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e), r = (a, i) => {
      if (Se(a) || Se(i))
        return m;
      let o = ve(a.value, i.value);
      return o.valid ? ((Ce(a) || Ce(i)) && t.dirty(), { status: t.value, value: o.data }) : (u(n2, { code: c.invalid_intersection_types }), m);
    };
    return n2.common.async ? Promise.all([this._def.left._parseAsync({ data: n2.data, path: n2.path, parent: n2 }), this._def.right._parseAsync({ data: n2.data, path: n2.path, parent: n2 })]).then(([a, i]) => r(a, i)) : r(this._def.left._parseSync({ data: n2.data, path: n2.path, parent: n2 }), this._def.right._parseSync({ data: n2.data, path: n2.path, parent: n2 }));
  }
};
H.create = (s, e, t) => new H({ left: s, right: e, typeName: p.ZodIntersection, ...g(t) });
var E = class extends v {
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== d.array)
      return u(n2, { code: c.invalid_type, expected: d.array, received: n2.parsedType }), m;
    if (n2.data.length < this._def.items.length)
      return u(n2, { code: c.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), m;
    !this._def.rest && n2.data.length > this._def.items.length && (u(n2, { code: c.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t.dirty());
    let a = [...n2.data].map((i, o) => {
      let f = this._def.items[o] || this._def.rest;
      return f ? f._parse(new N(n2, i, n2.path, o)) : null;
    }).filter((i) => !!i);
    return n2.common.async ? Promise.all(a).then((i) => k.mergeArray(t, i)) : k.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new E({ ...this._def, rest: e });
  }
};
E.create = (s, e) => {
  if (!Array.isArray(s))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new E({ items: s, typeName: p.ZodTuple, rest: null, ...g(e) });
};
var G = class extends v {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== d.object)
      return u(n2, { code: c.invalid_type, expected: d.object, received: n2.parsedType }), m;
    let r = [], a = this._def.keyType, i = this._def.valueType;
    for (let o in n2.data)
      r.push({ key: a._parse(new N(n2, o, n2.path, o)), value: i._parse(new N(n2, n2.data[o], n2.path, o)) });
    return n2.common.async ? k.mergeObjectAsync(t, r) : k.mergeObjectSync(t, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n2) {
    return t instanceof v ? new G({ keyType: e, valueType: t, typeName: p.ZodRecord, ...g(n2) }) : new G({ keyType: O.create(), valueType: e, typeName: p.ZodRecord, ...g(t) });
  }
};
var oe = class extends v {
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== d.map)
      return u(n2, { code: c.invalid_type, expected: d.map, received: n2.parsedType }), m;
    let r = this._def.keyType, a = this._def.valueType, i = [...n2.data.entries()].map(([o, f], l) => ({ key: r._parse(new N(n2, o, n2.path, [l, "key"])), value: a._parse(new N(n2, f, n2.path, [l, "value"])) }));
    if (n2.common.async) {
      let o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let f of i) {
          let l = await f.key, y = await f.value;
          if (l.status === "aborted" || y.status === "aborted")
            return m;
          (l.status === "dirty" || y.status === "dirty") && t.dirty(), o.set(l.value, y.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      let o = /* @__PURE__ */ new Map();
      for (let f of i) {
        let l = f.key, y = f.value;
        if (l.status === "aborted" || y.status === "aborted")
          return m;
        (l.status === "dirty" || y.status === "dirty") && t.dirty(), o.set(l.value, y.value);
      }
      return { status: t.value, value: o };
    }
  }
};
oe.create = (s, e, t) => new oe({ valueType: e, keyType: s, typeName: p.ZodMap, ...g(t) });
var z2 = class extends v {
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e);
    if (n2.parsedType !== d.set)
      return u(n2, { code: c.invalid_type, expected: d.set, received: n2.parsedType }), m;
    let r = this._def;
    r.minSize !== null && n2.data.size < r.minSize.value && (u(n2, { code: c.too_small, minimum: r.minSize.value, type: "set", inclusive: true, exact: false, message: r.minSize.message }), t.dirty()), r.maxSize !== null && n2.data.size > r.maxSize.value && (u(n2, { code: c.too_big, maximum: r.maxSize.value, type: "set", inclusive: true, exact: false, message: r.maxSize.message }), t.dirty());
    let a = this._def.valueType;
    function i(f) {
      let l = /* @__PURE__ */ new Set();
      for (let y of f) {
        if (y.status === "aborted")
          return m;
        y.status === "dirty" && t.dirty(), l.add(y.value);
      }
      return { status: t.value, value: l };
    }
    let o = [...n2.data.values()].map((f, l) => a._parse(new N(n2, f, n2.path, l)));
    return n2.common.async ? Promise.all(o).then((f) => i(f)) : i(o);
  }
  min(e, t) {
    return new z2({ ...this._def, minSize: { value: e, message: h.toString(t) } });
  }
  max(e, t) {
    return new z2({ ...this._def, maxSize: { value: e, message: h.toString(t) } });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
z2.create = (s, e) => new z2({ valueType: s, minSize: null, maxSize: null, typeName: p.ZodSet, ...g(e) });
var L = class extends v {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    let { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== d.function)
      return u(t, { code: c.invalid_type, expected: d.function, received: t.parsedType }), m;
    function n2(o, f) {
      return me({ data: o, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, pe(), le].filter((l) => !!l), issueData: { code: c.invalid_arguments, argumentsError: f } });
    }
    function r(o, f) {
      return me({ data: o, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, pe(), le].filter((l) => !!l), issueData: { code: c.invalid_return_type, returnTypeError: f } });
    }
    let a = { errorMap: t.common.contextualErrorMap }, i = t.data;
    return this._def.returns instanceof U ? b(async (...o) => {
      let f = new S([]), l = await this._def.args.parseAsync(o, a).catch((he) => {
        throw f.addIssue(n2(o, he)), f;
      }), y = await i(...l);
      return await this._def.returns._def.type.parseAsync(y, a).catch((he) => {
        throw f.addIssue(r(y, he)), f;
      });
    }) : b((...o) => {
      let f = this._def.args.safeParse(o, a);
      if (!f.success)
        throw new S([n2(o, f.error)]);
      let l = i(...f.data), y = this._def.returns.safeParse(l, a);
      if (!y.success)
        throw new S([r(l, y.error)]);
      return y.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new L({ ...this._def, args: E.create(e).rest(Z.create()) });
  }
  returns(e) {
    return new L({ ...this._def, returns: e });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n2) {
    return new L({ args: e || E.create([]).rest(Z.create()), returns: t || Z.create(), typeName: p.ZodFunction, ...g(n2) });
  }
};
var Q = class extends v {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    let { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
};
Q.create = (s, e) => new Q({ getter: s, typeName: p.ZodLazy, ...g(e) });
var X = class extends v {
  _parse(e) {
    if (e.data !== this._def.value) {
      let t = this._getOrReturnCtx(e);
      return u(t, { received: t.data, code: c.invalid_literal, expected: this._def.value }), m;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
X.create = (s, e) => new X({ value: s, typeName: p.ZodLiteral, ...g(e) });
function Oe(s, e) {
  return new A({ values: s, typeName: p.ZodEnum, ...g(e) });
}
var A = class extends v {
  _parse(e) {
    if (typeof e.data != "string") {
      let t = this._getOrReturnCtx(e), n2 = this._def.values;
      return u(t, { expected: _.joinValues(n2), received: t.parsedType, code: c.invalid_type }), m;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      let t = this._getOrReturnCtx(e), n2 = this._def.values;
      return u(t, { received: t.data, code: c.invalid_enum_value, options: n2 }), m;
    }
    return b(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let e = {};
    for (let t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    let e = {};
    for (let t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    let e = {};
    for (let t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return A.create(e);
  }
  exclude(e) {
    return A.create(this.options.filter((t) => !e.includes(t)));
  }
};
A.create = Oe;
var K = class extends v {
  _parse(e) {
    let t = _.getValidEnumValues(this._def.values), n2 = this._getOrReturnCtx(e);
    if (n2.parsedType !== d.string && n2.parsedType !== d.number) {
      let r = _.objectValues(t);
      return u(n2, { expected: _.joinValues(r), received: n2.parsedType, code: c.invalid_type }), m;
    }
    if (t.indexOf(e.data) === -1) {
      let r = _.objectValues(t);
      return u(n2, { received: n2.data, code: c.invalid_enum_value, options: r }), m;
    }
    return b(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
K.create = (s, e) => new K({ values: s, typeName: p.ZodNativeEnum, ...g(e) });
var U = class extends v {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    let { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== d.promise && t.common.async === false)
      return u(t, { code: c.invalid_type, expected: d.promise, received: t.parsedType }), m;
    let n2 = t.parsedType === d.promise ? t.data : Promise.resolve(t.data);
    return b(n2.then((r) => this._def.type.parseAsync(r, { path: t.path, errorMap: t.common.contextualErrorMap })));
  }
};
U.create = (s, e) => new U({ type: s, typeName: p.ZodPromise, ...g(e) });
var I = class extends v {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === p.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e), r = this._def.effect || null;
    if (r.type === "preprocess") {
      let i = r.transform(n2.data);
      return n2.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({ data: o, path: n2.path, parent: n2 })) : this._def.schema._parseSync({ data: i, path: n2.path, parent: n2 });
    }
    let a = { addIssue: (i) => {
      u(n2, i), i.fatal ? t.abort() : t.dirty();
    }, get path() {
      return n2.path;
    } };
    if (a.addIssue = a.addIssue.bind(a), r.type === "refinement") {
      let i = (o) => {
        let f = r.refinement(o, a);
        if (n2.common.async)
          return Promise.resolve(f);
        if (f instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n2.common.async === false) {
        let o = this._def.schema._parseSync({ data: n2.data, path: n2.path, parent: n2 });
        return o.status === "aborted" ? m : (o.status === "dirty" && t.dirty(), i(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n2.data, path: n2.path, parent: n2 }).then((o) => o.status === "aborted" ? m : (o.status === "dirty" && t.dirty(), i(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (r.type === "transform")
      if (n2.common.async === false) {
        let i = this._def.schema._parseSync({ data: n2.data, path: n2.path, parent: n2 });
        if (!ge(i))
          return i;
        let o = r.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n2.data, path: n2.path, parent: n2 }).then((i) => ge(i) ? Promise.resolve(r.transform(i.value, a)).then((o) => ({ status: t.value, value: o })) : i);
    _.assertNever(r);
  }
};
I.create = (s, e, t) => new I({ schema: s, typeName: p.ZodEffects, effect: e, ...g(t) });
I.createWithPreprocess = (s, e, t) => new I({ schema: e, effect: { type: "preprocess", transform: s }, typeName: p.ZodEffects, ...g(t) });
var j = class extends v {
  _parse(e) {
    return this._getType(e) === d.undefined ? b(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
j.create = (s, e) => new j({ innerType: s, typeName: p.ZodOptional, ...g(e) });
var V = class extends v {
  _parse(e) {
    return this._getType(e) === d.null ? b(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
V.create = (s, e) => new V({ innerType: s, typeName: p.ZodNullable, ...g(e) });
var F = class extends v {
  _parse(e) {
    let { ctx: t } = this._processInputParams(e), n2 = t.data;
    return t.parsedType === d.undefined && (n2 = this._def.defaultValue()), this._def.innerType._parse({ data: n2, path: t.path, parent: t });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
F.create = (s, e) => new F({ innerType: s, typeName: p.ZodDefault, defaultValue: typeof e.default == "function" ? e.default : () => e.default, ...g(e) });
var ce = class extends v {
  _parse(e) {
    let { ctx: t } = this._processInputParams(e), n2 = { ...t, common: { ...t.common, issues: [] } }, r = this._def.innerType._parse({ data: n2.data, path: n2.path, parent: { ...n2 } });
    return ye(r) ? r.then((a) => ({ status: "valid", value: a.status === "valid" ? a.value : this._def.catchValue({ get error() {
      return new S(n2.common.issues);
    }, input: n2.data }) })) : { status: "valid", value: r.status === "valid" ? r.value : this._def.catchValue({ get error() {
      return new S(n2.common.issues);
    }, input: n2.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ce.create = (s, e) => new ce({ innerType: s, typeName: p.ZodCatch, catchValue: typeof e.catch == "function" ? e.catch : () => e.catch, ...g(e) });
var de = class extends v {
  _parse(e) {
    if (this._getType(e) !== d.nan) {
      let n2 = this._getOrReturnCtx(e);
      return u(n2, { code: c.invalid_type, expected: d.nan, received: n2.parsedType }), m;
    }
    return { status: "valid", value: e.data };
  }
};
de.create = (s) => new de({ typeName: p.ZodNaN, ...g(s) });
var Fe = Symbol("zod_brand");
var _e = class extends v {
  _parse(e) {
    let { ctx: t } = this._processInputParams(e), n2 = t.data;
    return this._def.type._parse({ data: n2, path: t.path, parent: t });
  }
  unwrap() {
    return this._def.type;
  }
};
var ee = class extends v {
  _parse(e) {
    let { status: t, ctx: n2 } = this._processInputParams(e);
    if (n2.common.async)
      return (async () => {
        let a = await this._def.in._parseAsync({ data: n2.data, path: n2.path, parent: n2 });
        return a.status === "aborted" ? m : a.status === "dirty" ? (t.dirty(), Re(a.value)) : this._def.out._parseAsync({ data: a.value, path: n2.path, parent: n2 });
      })();
    {
      let r = this._def.in._parseSync({ data: n2.data, path: n2.path, parent: n2 });
      return r.status === "aborted" ? m : r.status === "dirty" ? (t.dirty(), { status: "dirty", value: r.value }) : this._def.out._parseSync({ data: r.value, path: n2.path, parent: n2 });
    }
  }
  static create(e, t) {
    return new ee({ in: e, out: t, typeName: p.ZodPipeline });
  }
};
var et = { object: x.lazycreate };
var p;
(function(s) {
  s.ZodString = "ZodString", s.ZodNumber = "ZodNumber", s.ZodNaN = "ZodNaN", s.ZodBigInt = "ZodBigInt", s.ZodBoolean = "ZodBoolean", s.ZodDate = "ZodDate", s.ZodSymbol = "ZodSymbol", s.ZodUndefined = "ZodUndefined", s.ZodNull = "ZodNull", s.ZodAny = "ZodAny", s.ZodUnknown = "ZodUnknown", s.ZodNever = "ZodNever", s.ZodVoid = "ZodVoid", s.ZodArray = "ZodArray", s.ZodObject = "ZodObject", s.ZodUnion = "ZodUnion", s.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", s.ZodIntersection = "ZodIntersection", s.ZodTuple = "ZodTuple", s.ZodRecord = "ZodRecord", s.ZodMap = "ZodMap", s.ZodSet = "ZodSet", s.ZodFunction = "ZodFunction", s.ZodLazy = "ZodLazy", s.ZodLiteral = "ZodLiteral", s.ZodEnum = "ZodEnum", s.ZodEffects = "ZodEffects", s.ZodNativeEnum = "ZodNativeEnum", s.ZodOptional = "ZodOptional", s.ZodNullable = "ZodNullable", s.ZodDefault = "ZodDefault", s.ZodCatch = "ZodCatch", s.ZodPromise = "ZodPromise", s.ZodBranded = "ZodBranded", s.ZodPipeline = "ZodPipeline";
})(p || (p = {}));
var te = O.create;
var Ee = M.create;
var tt = de.create;
var st = P.create;
var xe = se.create;
var nt = D.create;
var rt = ne.create;
var at = q.create;
var it = J.create;
var ot = re.create;
var ct = Z.create;
var dt = R.create;
var ut = ae.create;
var ke = C.create;
var w = x.create;
var lt = x.strictCreate;
var fe = Y.create;
var ft = ie.create;
var ht = H.create;
var pt = E.create;
var mt = G.create;
var gt = oe.create;
var yt = z2.create;
var vt = L.create;
var _t = Q.create;
var T = X.create;
var xt = A.create;
var kt = K.create;
var bt = U.create;
var wt = I.create;
var Tt = j.create;
var St = V.create;
var Ct = I.createWithPreprocess;
var Nt = ee.create;
var Ie = w({ type: T("path") });
var It = w({ type: T("domain"), level: fe([T("tld"), T("subdomain"), Ee()]) });
var jt = w({ type: T("query"), parameter: te().default("lang") });
var We = w({ type: T("url"), variant: fe([Ie]).default(Ie.parse({ type: "path" })) });
var Rt = w({ type: T("cookie"), key: te().default("language") });
var qe = w({ type: T("acceptLanguageHeader") });
var Je = w({ type: T("navigator") });
var Ye = w({ type: T("localStorage"), key: te().default("language") });
var At = w({ type: T("sessionStorage"), key: te().default("language") });
var He = fe([We, qe, Je, Ye]);
var Ge = w({ cache: T("build-time").default("build-time") });
var Qe = w({ debug: xe().default(false), languageNegotiation: w({ strict: xe().optional().default(false), strategies: ke(He).min(1, "You must define at least one language negotiation strategy.").transform((s) => s) }), resources: Ge.default({ cache: "build-time" }), routing: w({ exclude: ke(te().startsWith("/")).default([]) }).default({ exclude: [] }) });
var be = (s) => Qe.parse(s);
function we(s) {
  return (e) => (t) => s({ settings: e, env: t });
}
var Xe = we(({ settings: s }) => ({ id: "inlang.sdk-js", config: async () => ({ sdk: be(s), ideExtension: Ke }) }));
var Ke = { messageReferenceMatchers: [async (s) => {
  let e = /(?<!\w){?i\(['"](?<messageId>\S+)['"]\)}?/gm, t = s.documentText, n2, r = [];
  for (; (n2 = e.exec(t)) !== null; ) {
    let a = (t.slice(0, Math.max(0, n2.index)).match(/\n/g) || []).length + 1, i = n2.index - t.lastIndexOf(`
`, n2.index - 1), o = n2.index + n2[0].length - t.lastIndexOf(`
`, n2.index + n2[0].length - 1), f = (t.slice(0, Math.max(0, n2.index + n2[0].length)).match(/\n/g) || []).length + 1;
    n2.groups && "messageId" in n2.groups && r.push({ messageId: n2.groups.messageId, position: { start: { line: a, character: i }, end: { line: f, character: o } } });
  }
  return r;
}], extractMessageOptions: [{ callback: (s) => `{i("${s}")}` }], documentSelectors: [{ language: "javascript" }, { language: "typescript" }, { language: "svelte" }] };

// package.json
var version = "0.11.8";

// src/adapter-sveltekit/vite-plugin/config.ts
import path2 from "node:path";
import { pathToFileURL } from "node:url";
import * as svelteKit from "@sveltejs/kit";

// ../../node_modules/vitefu/src/index.js
var import_sync = __toESM(require_sync(), 1);
import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";
var pnp;
if (process.versions.pnp) {
  try {
    const { createRequire } = (await import("module")).default;
    pnp = createRequire(import.meta.url)("pnpapi");
  } catch {
  }
}
async function findDepPkgJsonPath(dep, parent) {
  if (pnp) {
    const depRoot = pnp.resolveToUnqualified(dep, parent);
    if (!depRoot)
      return void 0;
    return path.join(depRoot, "package.json");
  }
  let root = await findClosestPkgJsonPath(parent);
  if (!root)
    return void 0;
  root = path.dirname(root);
  while (root) {
    const pkg = path.join(root, "node_modules", dep, "package.json");
    try {
      await fs.access(pkg);
      return fsSync.realpathSync(pkg);
    } catch {
    }
    const nextRoot = path.dirname(root);
    if (nextRoot === root)
      break;
    root = nextRoot;
  }
  return void 0;
}
async function findClosestPkgJsonPath(dir, predicate = void 0) {
  if (dir.endsWith("package.json")) {
    dir = path.dirname(dir);
  }
  while (dir) {
    const pkg = path.join(dir, "package.json");
    try {
      const stat2 = await fs.stat(pkg);
      if (stat2.isFile() && (!predicate || await predicate(pkg))) {
        return pkg;
      }
    } catch {
    }
    const nextDir = path.dirname(dir);
    if (nextDir === dir)
      break;
    dir = nextDir;
  }
  return void 0;
}

// src/ast-transforms/utils/js.util.ts
var import_ts_dedent7 = __toESM(require_dist(), 1);
import { Project, Node as Node2, QuoteKind, IndentationText, ScriptKind } from "ts-morph";
var parseCode = (code, filePath) => new Project({
  manipulationSettings: {
    quoteKind: QuoteKind.Single,
    indentationText: IndentationText.Tab,
    useTrailingCommas: true
  }
}).createSourceFile(filePath || "_dummy_.ts", code, { overwrite: true });
var printCode = (node) => node && node.print({ scriptKind: ScriptKind.TS }).trim() || "";
var codeToSourceFile = (code, filePath) => parseCode((0, import_ts_dedent7.dedent)(code), filePath);
var codeToNode = (code) => {
  const node = codeToSourceFile(code, "").getStatement(Node2.isVariableStatement)?.getDeclarationList().getDeclarations()[0];
  if (!node) {
    throw new InlangException("Could not find variable declaration.");
  }
  if (node.getName() !== "x") {
    throw new InlangException("The variable must be named 'x'.");
  }
  const initializer = node.getInitializer();
  if (!initializer) {
    throw new InlangException("Could not find variable initializer.");
  }
  return initializer;
};
var nodeToCode = (node) => printCode(node);

// src/adapter-sveltekit/vite-plugin/config.ts
import { Node as Node4 } from "ts-morph";

// src/ast-transforms/utils/exports.ts
var import_ts_dedent8 = __toESM(require_dist(), 1);
import { Node as Node3, SyntaxKind } from "ts-morph";
var findExport = (sourceFile, name) => {
  if (!Node3.isSourceFile(sourceFile))
    return;
  const exportVariableStatements = sourceFile.getVariableStatements().filter((statement) => statement.getModifiers().some((m2) => m2.isKind(SyntaxKind.ExportKeyword)));
  for (const variableStatements of exportVariableStatements) {
    const declarations = variableStatements.getDeclarations();
    for (const declaration of declarations) {
      const nameNode = declaration.getNameNode();
      if (nameNode && nameNode.getText() === name) {
        return declaration;
      }
    }
  }
  const exportFunctionDeclarations = sourceFile.getFunctions().filter(
    (declaration) => declaration.getModifiers().some((m2) => m2.isKind(SyntaxKind.ExportKeyword))
  );
  for (const declaration of exportFunctionDeclarations) {
    const nameNode = declaration.getNameNode();
    if (nameNode && nameNode.getText() === name) {
      return declaration;
    }
  }
  const exportDeclararions = sourceFile.getExportDeclarations();
  for (const declaration of exportDeclararions) {
    const namedExports = declaration.getNamedExports();
    for (const namedExport of namedExports) {
      if ((namedExport.getAliasNode() || namedExport.getNameNode()).getText())
        return namedExport;
    }
  }
  return;
};
var findOrCreateExport = (sourceFile, name, defaultImplementation) => {
  const fnExport = findExport(sourceFile, name);
  if (fnExport)
    return fnExport;
  const isVariableAlreadyDefined = !!sourceFile.getVariableStatements().filter(
    (statement) => statement.getDeclarationList().getDeclarations().some((declaration) => declaration.getName() === name)
  ).length;
  if (isVariableAlreadyDefined)
    throw new InlangSdkException(import_ts_dedent8.dedent`
			Variable '${name}' already exists. The inlang SDK needs to export a variable with this name.
			Please rename the variable in this file.
		`);
  const createdFn = codeToSourceFile(`export const ${name} = ${defaultImplementation}`);
  sourceFile.addVariableStatement(createdFn.getVariableStatement(name).getStructure());
  return findExport(sourceFile, name);
};

// src/adapter-sveltekit/vite-plugin/config.ts
var doesPathExist = async (path5) => !!await stat(path5).catch(() => false);
var cwdFolderPath = process.cwd();
var inlangConfigFilePath = path2.resolve(cwdFolderPath, "inlang.config.js");
var configPromise = void 0;
var getTransformConfig = async () => {
  if (configPromise)
    return configPromise;
  return configPromise = new Promise(async (resolve) => {
    await createInlangConfigIfNotPresentYet();
    await updateSdkPluginVersion();
    const inlangConfigAsString = await readFile2(inlangConfigFilePath, { encoding: "utf-8" });
    const [, exception] = await testConfigFile({
      file: inlangConfigAsString,
      env: await initInlangEnvironment()
    });
    if (exception) {
      throw exception;
    }
    const inlangConfigModule = await import(pathToFileURL(inlangConfigFilePath).toString());
    const inlangConfig = await initConfig(inlangConfigModule);
    const { default: svelteConfig } = await import(pathToFileURL(path2.resolve(cwdFolderPath, "svelte.config.js")).toString());
    const files = {
      appTemplate: path2.resolve(
        cwdFolderPath,
        svelteConfig.kit?.files?.appTemplate || path2.resolve("src", "app.html")
      ),
      routes: path2.resolve(
        cwdFolderPath,
        svelteConfig.kit?.files?.routes || path2.resolve("src", "routes")
      ),
      serverHooks: path2.resolve(
        cwdFolderPath,
        svelteConfig.kit?.files?.hooks?.server || path2.resolve("src", "hooks.server")
      )
    };
    assertConfigWithSdk(inlangConfig);
    inlangConfig.sdk = be(inlangConfig.sdk);
    const languageInUrl = inlangConfig?.sdk?.languageNegotiation?.strategies?.some(({ type }) => type === "url") || false;
    const rootRoutesFolder = path2.resolve(files.routes, languageInUrl ? "[lang]" : "");
    const isStatic = await shouldContentBePrerendered(files.routes) || await shouldContentBePrerendered(rootRoutesFolder);
    const usesTypeScript = await doesPathExist(path2.resolve(cwdFolderPath, "tsconfig.json"));
    const svelteKitVersion = svelteKit.VERSION || await getInstalledVersionOfPackage("@sveltejs/kit");
    resolve({
      cwdFolderPath,
      debug: !!inlangConfig.sdk?.debug,
      languageInUrl,
      isStatic,
      rootRoutesFolder,
      inlang: inlangConfig,
      svelteKit: {
        version: svelteKitVersion,
        usesTypeScript,
        files
      }
    });
  });
};
var resetConfig = () => configPromise = void 0;
var InlangSdkConfigException = class extends InlangSdkException {
};
function assertConfigWithSdk(config) {
  if (!config) {
    throw new InlangSdkConfigException(import_ts_dedent9.dedent`
			Could not locate 'inlang.config.js' at the root of your project (${inlangConfigFilePath}).
			Make sure the file exists. You can generate the file using the inlang CLI.
			See https://inlang.com/documentation/apps/inlang-cli
		`);
  }
  if (!("sdk" in config)) {
    throw new InlangSdkConfigException(import_ts_dedent9.dedent`
			Invalid config. Make sure to add the 'sdkPlugin' to your 'inlang.config.js' file.
			See https://inlang.com/documentation/sdk/configuration
		`);
  }
}
var createInlangConfigIfNotPresentYet = async () => {
  const inlangConfigExists = await doesPathExist(inlangConfigFilePath);
  if (inlangConfigExists)
    return;
  await createDemoResources();
  return writeFile2(
    inlangConfigFilePath,
    `
/**
 * @type { import("@inlang/core/config").DefineConfig }
 */
export async function defineConfig(env) {
	const { default: jsonPlugin } = await env.$import(
		"https://cdn.jsdelivr.net/npm/@inlang/plugin-json@3/dist/index.js"
	)
	const { default: sdkPlugin } = await env.$import(
		"https://cdn.jsdelivr.net/npm/@inlang/sdk-js-plugin/dist/index.js"
	)

	return {
		referenceLanguage: "en",
		plugins: [
			jsonPlugin({
				pathPattern: "./languages/{language}.json",
			}),
			sdkPlugin({
				languageNegotiation: {
					strategies: [{ type: "localStorage" }]
				}
			}),
		],
	}
}
`
  );
};
var createDemoResources = async () => {
  const resourcesFolder = path2.resolve(cwdFolderPath, "languages");
  if (!await doesPathExist(resourcesFolder)) {
    await mkdir(path2.resolve(resourcesFolder));
  }
  await writeFile2(
    path2.resolve(resourcesFolder, "en.json"),
    import_ts_dedent9.dedent`
		{
		  "welcome": "Welcome to inlang"
		}
	`,
    { encoding: "utf-8" }
  );
  await writeFile2(
    path2.resolve(resourcesFolder, "de.json"),
    import_ts_dedent9.dedent`
		{
		  "welcome": "Willkommen bei inlang"
		}
	`,
    { encoding: "utf-8" }
  );
};
var shouldContentBePrerendered = async (routesFolder) => {
  const filesToLookFor = ["+layout.server.js", "+layout.server.ts", "+layout.js", "+layout.ts"];
  const prerenderExportVCalues = await Promise.all(
    filesToLookFor.map(async (file) => {
      const filePath = path2.resolve(routesFolder, file);
      const contents = await readFile2(filePath, { encoding: "utf-8" }).catch(() => void 0);
      if (!contents || !contents.trim())
        return void 0;
      const sourceFile = codeToSourceFile(contents);
      const prerenderExport = findExport(sourceFile, "prerender");
      if (!prerenderExport) {
        return void 0;
      }
      if (!Node4.isVariableDeclaration(prerenderExport)) {
        return void 0;
      }
      return prerenderExport.getInitializer();
    })
  );
  return prerenderExportVCalues.map(
    (node) => Node4.isTrueLiteral(node) || Node4.isStringLiteral(node) && node.getLiteralText() === "auto"
  ).some(Boolean);
};
var updateSdkPluginVersion = async () => {
  const inlangConfigAsString = await readFile2(inlangConfigFilePath, { encoding: "utf-8" });
  const REGEX_PLUGIN_VERSION = /https:\/\/cdn\.jsdelivr\.net\/npm\/@inlang\/sdk-js(-plugin)?@?(.*)?\/dist(\/plugin)?\/index\.js/g;
  const newConfig = inlangConfigAsString.replace(
    REGEX_PLUGIN_VERSION,
    `https://cdn.jsdelivr.net/npm/@inlang/sdk-js-plugin@${version}/dist/index.js`
  );
  if (inlangConfigAsString !== newConfig) {
    console.info(
      `Updating 'inlang.config.js' to use the correct version of '@inlang/sdk-js-plugin' (${version})`
    );
    await writeFile2(inlangConfigFilePath, newConfig);
  }
};
var getInstalledVersionOfPackage = async (pkg) => {
  const pkgJsonPath = await findDepPkgJsonPath(pkg, cwdFolderPath);
  if (!pkgJsonPath)
    return void 0;
  const pkgJson = JSON.parse(await readFile2(pkgJsonPath, { encoding: "utf-8" }));
  return pkgJson.version;
};

// src/adapter-sveltekit/vite-plugin/checks/routes.ts
var assertRoutesFolderPathExists = async (config) => {
  if (!await doesPathExist(config.rootRoutesFolder)) {
    throw new InlangException(import_ts_dedent10.dedent`

			Could not find the folder '${config.rootRoutesFolder.replace(config.cwdFolderPath, "")}'.
			It is needed in order to circumvent a current limitation of SvelteKit. See https://github.com/inlang/inlang/issues/647.
			Please create the folder and move all existing route files into it.

		`);
  }
};
var assertNecessaryFilesArePresent = async (config) => {
  const preferredFileEnding = config.svelteKit.usesTypeScript ? "ts" : "js";
  const getPathForFileType = (fileType, fileEnding = preferredFileEnding) => {
    switch (fileType) {
      case "hooks.server.js":
        return `${config.svelteKit.files.serverHooks}.${fileEnding}`;
      case "[language].json":
        return path3.resolve(
          config.svelteKit.files.routes,
          "inlang",
          "[language].json",
          `+server.${fileEnding}`
        );
      case "+layout.server.js":
        return path3.resolve(config.svelteKit.files.routes, `+layout.server.${fileEnding}`);
      case "+layout.js":
        return path3.resolve(config.svelteKit.files.routes, `+layout.${fileEnding}`);
      case "+layout.svelte":
        return path3.resolve(config.svelteKit.files.routes, `+layout.svelte`);
      case "+page.server.js":
        return path3.resolve(config.svelteKit.files.routes, `+page.server.${fileEnding}`);
      case "+page.js":
        return path3.resolve(config.svelteKit.files.routes, `+page.${fileEnding}`);
      case "+page.svelte":
        return path3.resolve(config.svelteKit.files.routes, `+page.svelte`);
    }
    throw new InlangSdkException(`Could not find path for file type '${fileType}'`);
  };
  const doesFileOfTypeExist = async (fileType) => {
    const files = fileType.endsWith(".svelte") ? [getPathForFileType(fileType)] : [getPathForFileType(fileType, "js"), getPathForFileType(fileType, "ts")];
    return (await Promise.all(files.map((file) => doesPathExist(file)))).some((result) => result);
  };
  const filesTypesToCreate = [
    `hooks.server.js`,
    `[language].json`,
    `+layout.server.js`,
    `+layout.js`,
    "+layout.svelte",
    ...config.isStatic && config.languageInUrl ? [`+page.js`, "+page.svelte"] : []
  ];
  const results = await Promise.all(
    filesTypesToCreate.map(
      (fileType) => (
        // eslint-disable-next-line no-async-promise-executor
        new Promise(async (resolve) => {
          if (await doesFileOfTypeExist(fileType)) {
            return resolve(false);
          }
          const path5 = getPathForFileType(fileType);
          await mkdir2(dirname(path5), { recursive: true }).catch(() => void 0);
          const message = import_ts_dedent10.dedent`
						This file was created by inlang.
						It is needed in order to circumvent a current limitation of SvelteKit. See https://github.com/inlang/inlang/issues/647
						You can remove this comment and modify the file as you like. We just need to make sure it exists.
						Please do not delete it (inlang will recreate it if needed).
					`;
          await writeFile3(
            path5,
            path5.endsWith(".svelte") ? `<!-- ${message} -->` : `/* ${message} */`
          );
          resolve(true);
        })
      )
    )
  );
  return results.some((result) => result);
};

// src/adapter-sveltekit/vite-plugin/fileInformation.ts
import path4, { normalize } from "node:path";
var scriptExtensions = [".js", ".ts"];
var getFileInformation = (config, rawId) => {
  const id = normalize(rawId);
  if (!id.startsWith(config.cwdFolderPath) || id.startsWith(path4.resolve(config.cwdFolderPath, "node_modules")) || id.startsWith(path4.resolve(config.cwdFolderPath, ".svelte-kit")))
    return void 0;
  if (scriptExtensions.map((ext2) => `${config.svelteKit.files.serverHooks}${ext2}`).includes(id)) {
    return {
      type: "hooks.server.js",
      root: true
    };
  }
  const { dir, name, ext } = path4.parse(id);
  const root = dir === config.svelteKit.files.routes;
  if (dir === path4.resolve(config.svelteKit.files.routes, "inlang", "[language].json") && name === "+server" && scriptExtensions.includes(ext)) {
    return {
      type: "[language].json",
      root: true
    };
  }
  if (name === "+server" && scriptExtensions.includes(ext)) {
    return {
      type: "+server.js",
      root
    };
  }
  if (name === "+layout.server" && scriptExtensions.includes(ext)) {
    return {
      type: "+layout.server.js",
      root
    };
  }
  if (name === "+layout" && scriptExtensions.includes(ext)) {
    return {
      type: "+layout.js",
      root
    };
  }
  if (name === "+layout" && ext === ".svelte") {
    return {
      type: "+layout.svelte",
      root
    };
  }
  if (name === "+page.server" && scriptExtensions.includes(ext)) {
    return {
      type: "+page.server.js",
      root
    };
  }
  if (name === "+page" && scriptExtensions.includes(ext)) {
    return {
      type: "+page.js",
      root
    };
  }
  if (name === "+page" && ext === ".svelte") {
    return {
      type: "+page.svelte",
      root
    };
  }
  if (name.endsWith(".server") && scriptExtensions.includes(ext)) {
    return {
      type: "*.server.js",
      root: false
    };
  }
  if (scriptExtensions.includes(ext)) {
    return {
      type: "*.js",
      root: false
    };
  }
  if (ext === ".svelte") {
    return {
      type: "*.svelte",
      root: false
    };
  }
  return void 0;
};
var filePathForOutput = (config, path5) => {
  const relativePath = path5.replace(config.cwdFolderPath, "");
  return relativePath.startsWith("/") ? relativePath.slice(1) : relativePath;
};

// src/adapter-sveltekit/ast-transforms/index.ts
var import_ts_dedent19 = __toESM(require_dist(), 1);

// src/adapter-sveltekit/ast-transforms/+layout.js.ts
var import_ts_dedent12 = __toESM(require_dist(), 1);

// src/ast-transforms/utils/imports.ts
import { Node as Node5 } from "ts-morph";
var removeImport = (sourceFile, path5, ...names) => {
  if (!Node5.isSourceFile(sourceFile))
    return;
  const importDeclarations = findImportDeclarations(sourceFile, path5);
  if (!importDeclarations.length)
    return;
  for (const importDeclaration of importDeclarations) {
    if (!importDeclaration.getImportClause()?.getNamedBindings())
      return;
    for (const name of names) {
      const importSpecifier = findNamedImportSpecifier(importDeclaration, name);
      if (!importSpecifier)
        continue;
      importSpecifier.remove();
    }
    if (
      // remove import completely
      !names.length || // if no names get passed
      !getNamedImportSpecifiers(importDeclaration).length
    ) {
      importDeclaration.remove();
    }
  }
};
var addImport = (sourceFile, path5, ...names) => {
  if (!Node5.isSourceFile(sourceFile))
    return;
  if (names.length === 0)
    return;
  const importDeclarations = findImportDeclarations(sourceFile, path5).filter((importDeclaration) => !!getNamedImportSpecifiers(importDeclaration).length).filter((importDeclaration) => !importDeclaration.isTypeOnly());
  if (!importDeclarations.length) {
    sourceFile.insertImportDeclarations(0, [
      {
        moduleSpecifier: path5,
        namedImports: names.map((name) => ({ name }))
      }
    ]);
    return;
  }
  for (const name of names) {
    if (importDeclarations.some(
      (importDeclaration2) => findNamedImportSpecifier(importDeclaration2, name)
    ))
      continue;
    const importDeclaration = importDeclarations[0];
    if (!findNamedImportSpecifier(importDeclaration, name))
      importDeclaration.addNamedImports(names.map((name2) => ({ name: name2 })));
  }
};
var textWithoutQuotes = (text) => text.replace(/^['"]|['"]$/g, "");
var findImportDeclarations = (sourceFile, path5) => sourceFile.forEachChildAsArray().map(
  (node) => Node5.isImportDeclaration(node) && textWithoutQuotes(node.getModuleSpecifier().getText()) === path5 ? node : void 0
).filter(Boolean);
var getNamedImportSpecifiers = (importDeclaration) => {
  const namedImports = importDeclaration.getImportClause()?.getNamedBindings();
  if (!Node5.isNamedImports(namedImports))
    return [];
  return namedImports.getElements();
};
var findNamedImportSpecifier = (importDeclaration, name) => getNamedImportSpecifiers(importDeclaration).find(
  (element) => (element.getAliasNode()?.getText() || element.getName()) === name
);
var getImportSpecifiers = (importDeclaration) => getNamedImportSpecifiers(importDeclaration);
var getImportSpecifiersAsStrings = (sourceFile, path5) => {
  const importDeclarations = findImportDeclarations(sourceFile, path5);
  const importSpecifiers = [];
  for (const importDeclaration of importDeclarations) {
    importSpecifiers.push(...getImportSpecifiers(importDeclaration));
  }
  return importSpecifiers.map((importSpecifier) => importSpecifier.getText().replace("as", ":"));
};
var isOptOutImportPresent = (sourceFile) => !!findImportDeclarations(sourceFile, "@inlang/sdk-js/no-transforms").length;
var isSdkImportPresent = (sourceFile) => !!findImportDeclarations(sourceFile, "@inlang/sdk-js").length;

// src/ast-transforms/utils/wrap.ts
import {
  Node as Node6,
  CallExpression,
  SyntaxKind as SyntaxKind2,
  ArrowFunction,
  FunctionExpression,
  ParenthesizedExpression,
  SatisfiesExpression
} from "ts-morph";
var import_ts_dedent11 = __toESM(require_dist(), 1);
var WRAP_IDENTIFIER = "$$_INLANG_WRAP_$$";
function wrapWithPlaceholder(node) {
  if (Node6.isArrowFunction(node) || Node6.isFunctionExpression(node) || Node6.isIdentifier(node) || Node6.isCallExpression(node) || Node6.isSatisfiesExpression(node) || Node6.isParenthesizedExpression(node)) {
    return node.replaceWithText(`$$_INLANG_WRAP_$$(${nodeToCode(node)})`);
  }
  throw new InlangSdkException(
    `Wrapping placeholder does not support node of kind '${node.getKindName()}'.`
  );
}
var createWrapperAst = (name, options = "") => codeToNode(`
	const x = ${name}(${options}).use(${WRAP_IDENTIFIER})
`);
var findWrappingPoint = (callExpression) => {
  if (!callExpression.getExpression().getText()) {
    throw new InlangSdkException(import_ts_dedent11.dedent`
			Could not find CallExpression in code:

			${callExpression.getText()}

		`);
  }
  const argument = callExpression.getArguments()[0];
  if (!argument) {
    throw new InlangSdkException(import_ts_dedent11.dedent`
			Could not find Argument in code:

			${callExpression.getText()}

		`);
  }
  return argument;
};
var findInsertionPoint = (callExpression) => {
  const insertionPoint = callExpression.getDescendantsOfKind(SyntaxKind2.Identifier).find((identifier) => identifier.getText() === WRAP_IDENTIFIER);
  if (!insertionPoint) {
    throw new InlangSdkException(import_ts_dedent11.dedent`
			Could not find insertion point in code:

			${callExpression.getText()}

		`);
  }
  return insertionPoint;
};
var mergeWrapperAst = (toWrapAst, wrapWithAst) => {
  const wrappingPoint = findWrappingPoint(toWrapAst);
  const insertionPoint = findInsertionPoint(wrapWithAst);
  insertionPoint.replaceWithText(nodeToCode(wrappingPoint));
};
var findFunctionExpression = (node) => {
  if (Node6.isVariableDeclaration(node)) {
    return node.getInitializer();
  }
  if (Node6.isFunctionDeclaration(node)) {
    return node;
  }
  throw new InlangSdkException(import_ts_dedent11.dedent`
		Could not find function expression in code:

		${node.getText()}

	`);
};
var findFunction = (node) => {
  if (ArrowFunction.isArrowFunction(node) || FunctionExpression.isFunctionExpression(node))
    return node;
  if (ParenthesizedExpression.isParenthesizedExpression(node) || SatisfiesExpression.isSatisfiesExpression(node)) {
    return findFunction(node.getExpression());
  }
  if (CallExpression.isCallExpression(node)) {
    return findFunction(node.getArguments()[0]);
  }
  throw new InlangException(`Could not find function for type '${node.getKindName()}'`);
};
var wrapExportedFunction = (sourceFile, options, wrapperFunctionName, exportName, defaultImplementation = "() => { }") => {
  const fnExport = findOrCreateExport(sourceFile, exportName, defaultImplementation);
  if (Node6.isFunctionDeclaration(fnExport)) {
    fnExport.toggleModifier("export", false);
    fnExport.replaceWithText(`export const ${exportName} = ${nodeToCode(fnExport)}`);
    wrapExportedFunction(sourceFile, options, wrapperFunctionName, exportName);
    return;
  }
  const fn = findFunctionExpression(fnExport);
  if (!fn) {
    throw new InlangSdkException(`Could not find exported function '${exportName}'`);
  }
  const imports = getImportSpecifiersAsStrings(sourceFile, "@inlang/sdk-js");
  if (imports.length) {
    const func = findFunction(fn);
    if (!func.getParameters().length) {
      func.insertParameters(0, [{ name: "_" }]);
    }
    func.insertParameters(1, [{ name: `{ ${imports} }` }]);
  }
  const wrapped = wrapWithPlaceholder(fn);
  const wrapWithAst = createWrapperAst(wrapperFunctionName, options);
  mergeWrapperAst(wrapped, wrapWithAst);
  wrapped.replaceWithText(nodeToCode(wrapWithAst));
};

// src/adapter-sveltekit/ast-transforms/+layout.js.ts
var addImports = (sourceFile, config, root, wrapperFunctionName) => {
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/shared", wrapperFunctionName);
  if (root && !config.languageInUrl) {
    addImport(sourceFile, "$app/environment", "browser");
    addImport(
      sourceFile,
      "@inlang/sdk-js/detectors/client",
      "initLocalStorageDetector",
      "navigatorDetector"
    );
  }
};
var getOptions = (config, root) => config.languageInUrl ? "{}" : import_ts_dedent12.dedent`
			{
				initDetectors: browser
					? () => [initLocalStorageDetector(), navigatorDetector]
					: undefined
			}`;
var transformLayoutJs = (filePath, config, code, root) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!root && !isSdkImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = root ? "initRootLayoutLoadWrapper" : "initLoadWrapper";
  addImports(sourceFile, config, root, wrapperFunctionName);
  const options = root ? getOptions(config, root) : void 0;
  wrapExportedFunction(sourceFile, options, wrapperFunctionName, "load");
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/+layout.server.js.ts
var transformLayoutServerJs = (filePath, config, code, root) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!root && !isSdkImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = root ? "initRootLayoutServerLoadWrapper" : "initServerLoadWrapper";
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", wrapperFunctionName);
  wrapExportedFunction(sourceFile, void 0, wrapperFunctionName, "load");
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/_.svelte.ts
var import_ts_dedent13 = __toESM(require_dist(), 1);

// src/adapter-sveltekit/ast-transforms/utils/imports.ts
var isOptOutImportPresent2 = ({ script, moduleScript }) => {
  const scriptSourceFile = codeToSourceFile(script);
  if (isOptOutImportPresent(scriptSourceFile))
    return true;
  const moduleScriptSourceFile = codeToSourceFile(moduleScript);
  if (isOptOutImportPresent(moduleScriptSourceFile))
    return true;
  return false;
};

// src/adapter-sveltekit/ast-transforms/utils/svelte.util.ts
import { parse } from "svelte/compiler";
var markupToAst = (markup) => parse(markup);
var REGEX_MODULE_SCRIPT_TAG = /(<script[^]*?context="module"[^]*?>\s*)([^]+?)(\s*<\/script>)/;
var REGEX_SCRIPT_TAG = /(<script[^]*?>\s*)([^]+?)(\s*<\/script>)/;
var REGEX_STYLE_TAG = /<style[^]*?>[^]+?<\/style>/;
var getSvelteFileParts = (code) => {
  let markupContent = code;
  let moduleScriptOpeningTag = '<script context="module">\n';
  let moduleScriptClosingTag = "\n</script>";
  let moduleScriptContent = "";
  let scriptOpeningTag = "<script>\n";
  let scriptClosingTag = "\n</script>";
  let scriptContent = "";
  let styleTag = "";
  const moduleScriptMatch = markupContent.match(REGEX_MODULE_SCRIPT_TAG);
  if (moduleScriptMatch) {
    moduleScriptOpeningTag = moduleScriptMatch[1];
    moduleScriptContent = moduleScriptMatch[2];
    moduleScriptClosingTag = moduleScriptMatch[3];
    markupContent = markupContent.replace(
      moduleScriptMatch[0],
      "{$_INLANG_MODULE_SCRIPT_PLACEHOLDER_$}"
    );
  }
  const scriptMatch = markupContent.match(REGEX_SCRIPT_TAG);
  if (scriptMatch) {
    scriptOpeningTag = scriptMatch[1];
    scriptContent = scriptMatch[2];
    scriptClosingTag = scriptMatch[3];
    markupContent = markupContent.replace(scriptMatch[0], "{$_INLANG_SCRIPT_PLACEHOLDER_$}");
  }
  const styleMatch = markupContent.match(REGEX_STYLE_TAG);
  if (styleMatch) {
    styleTag = styleMatch[0];
    markupContent = markupContent.replace(styleMatch[0], "{$_INLANG_STYLE_PLACEHOLDER_$}");
  }
  return {
    get moduleScript() {
      return moduleScriptContent;
    },
    set moduleScript(newModuleScript) {
      moduleScriptContent = newModuleScript;
    },
    get script() {
      return scriptContent;
    },
    set script(newScript) {
      scriptContent = newScript;
    },
    get markup() {
      return markupContent;
    },
    set markup(newMarkup) {
      markupContent = newMarkup;
    },
    toString() {
      let code2 = markupContent;
      code2 = replacePlaceholder(
        code2,
        "{$_INLANG_SCRIPT_PLACEHOLDER_$}",
        scriptOpeningTag,
        scriptClosingTag,
        scriptContent
      );
      code2 = replacePlaceholder(
        code2,
        "{$_INLANG_MODULE_SCRIPT_PLACEHOLDER_$}",
        moduleScriptOpeningTag,
        moduleScriptClosingTag,
        moduleScriptContent
      );
      code2 = replacePlaceholder(code2, "{$_INLANG_STYLE_PLACEHOLDER_$}", "", "", styleTag, false);
      return code2.trim();
    }
  };
};
var replacePlaceholder = (code, placeholder, openTag, closeTag, content, insertAtTheTop = true) => {
  if (code.includes(placeholder)) {
    const newContent = content ? openTag + content + closeTag : "";
    return code.replace(placeholder, newContent);
  } else if (content) {
    const newCode = insertAtTheTop ? `${placeholder}
${code}` : `${code}
${placeholder}`;
    return replacePlaceholder(newCode, placeholder, openTag, closeTag, content);
  }
  return code;
};

// src/adapter-sveltekit/ast-transforms/_.svelte.ts
var transformSvelte = (filePath, config, code) => {
  const fileParts = getSvelteFileParts(code);
  if (isOptOutImportPresent2(fileParts))
    return code;
  transform(filePath, config, fileParts);
  return fileParts.toString();
};
var transform = (filePath, config, fileParts) => {
  fileParts.script = transformScriptTag(filePath, config, fileParts.script);
  fileParts.moduleScript = transformScriptTag(filePath, config, fileParts.moduleScript);
};
var transformScriptTag = (filePath, config, script) => {
  const sourceFile = codeToSourceFile(script, filePath);
  transformSdkImports(config, sourceFile);
  return nodeToCode(sourceFile);
};
var transformSdkImports = (config, sourceFile) => {
  if (!isSdkImportPresent(sourceFile))
    return;
  addImport(
    sourceFile,
    `@inlang/sdk-js/adapter-sveltekit/client/${config.languageInUrl ? "not-reactive" : "reactive-workaround"}`,
    "getRuntimeFromContext"
  );
  const imports = getImportSpecifiersAsStrings(sourceFile, "@inlang/sdk-js");
  const importDeclarations = findImportDeclarations(sourceFile, "@inlang/sdk-js");
  importDeclarations[0].replaceWithText(import_ts_dedent13.dedent`
		const { ${imports} } = getRuntimeFromContext()
	`);
  removeImport(sourceFile, "@inlang/sdk-js");
};

// src/adapter-sveltekit/ast-transforms/+layout.svelte.ts
var import_ts_dedent14 = __toESM(require_dist(), 1);

// src/adapter-sveltekit/ast-transforms/utils/exports.ts
import { Node as Node7 } from "ts-morph";
var addOrMoveDataExportAndReturnIndex = (sourceFile) => {
  const statements = sourceFile.getStatements();
  let index = statements.findIndex((statement) => !Node7.isImportDeclaration(statement));
  if (index < 0)
    index = statements.length;
  const dataExport = findExport(sourceFile, "data");
  if (dataExport) {
    ;
    dataExport.getParent().getParent()?.setOrder(index);
  } else {
    sourceFile.insertStatements(index, `export let data`);
  }
  return index;
};

// src/adapter-sveltekit/ast-transforms/utils/markup.ts
var canNodeBeWrapped = (node) => {
  if (node.type === "MustacheTag" && node.expression.type === "Identifier" && node.expression.name.startsWith("$_INLANG_"))
    return false;
  if (node.type === "Window")
    return false;
  if (node.type === "Document")
    return false;
  if (node.type === "Head")
    return false;
  if (node.type === "Body")
    return false;
  if (node.type === "Options")
    return false;
  return true;
};
var wrapNodes = (s, ast, start, end, wrapWith) => {
  const nodes = ast.html.children?.slice(start, end) || [];
  if (!nodes.length)
    return;
  if (!wrapWith.includes("$$_INLANG_WRAP_$$"))
    throw new InlangSdkException("Could not find wrapping point.");
  const [before, after] = wrapWith.split("$$_INLANG_WRAP_$$");
  s.appendLeft(nodes.at(0).start, before);
  s.appendLeft(nodes.at(-1).end, after);
};
var wrapMarkupChildren = (s, ast, wrapWith) => {
  const children = [...ast.html.children?.values() || []];
  let start = 0;
  for (const [i, child] of children.entries()) {
    if (canNodeBeWrapped(child)) {
      continue;
    } else {
      wrapNodes(s, ast, start, i, wrapWith);
      start = i + 1;
    }
  }
  wrapNodes(s, ast, start, children.length, wrapWith);
};
var isMarkupEmpty = (ast) => !(ast.html.children || []).filter(
  (c2) => !(c2.type === "Comment" || c2.type === "Text" && !c2.data.trim())
).length;
var insertSlotIfEmptyFile = (s, ast) => {
  if (isMarkupEmpty(ast)) {
    s.appendRight(ast.html.end || 0, "<slot />");
    return true;
  }
  return false;
};

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c2 = chars.charCodeAt(i);
  intToChar[i] = c2;
  charToInt[c2] = i;
}
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j2 = 0; j2 < line.length; j2++) {
      const segment = line[j2];
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j2 > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j2) {
  const next = segment[j2];
  let num = next - state[j2];
  state[j2] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

// node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa2 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j2 = lineOffsets.length;
    while (i < j2) {
      const m2 = i + j2 >> 1;
      if (index < lineOffsets[m2]) {
        j2 = m2;
      } else {
        i = m2 + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [options.source ? getRelativePath(options.file || "", options.source) : options.file || ""],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_2, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re2, str) {
      let match;
      const matches = [];
      while (match = re2.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// src/adapter-sveltekit/magic-string.ts
var MagicString2 = MagicString;

// src/adapter-sveltekit/ast-transforms/+layout.svelte.ts
var transformLayoutSvelte = (filePath, config, code, root) => {
  const fileParts = getSvelteFileParts(code);
  if (isOptOutImportPresent2(fileParts))
    return code;
  if (!root)
    return transformSvelte(filePath, config, code);
  fileParts.script = transformScript(filePath, config, fileParts.script);
  fileParts.markup = transformMarkup(config, fileParts.markup);
  return transformSvelte(filePath, config, fileParts.toString());
};
var transformScript = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/client/shared", "addRuntimeToGlobalThis");
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/shared", "getRuntimeFromData");
  addImport(
    sourceFile,
    `@inlang/sdk-js/adapter-sveltekit/client/${config.languageInUrl ? "not-reactive" : "reactive-workaround"}`,
    "addRuntimeToContext",
    "getRuntimeFromContext"
  );
  addImport(sourceFile, "$app/environment", "browser");
  removeImport(sourceFile, "@inlang/sdk-js", "i", "language", "referenceLanguage");
  const index = addOrMoveDataExportAndReturnIndex(sourceFile);
  sourceFile.insertStatements(
    index + 1,
    import_ts_dedent14.dedent`
			$: if (browser) {
				addRuntimeToGlobalThis(getRuntimeFromData(data))
				addRuntimeToContext(getRuntimeFromData(data))
				;({ i, language } = getRuntimeFromContext())
				document.body.parentElement?.setAttribute('lang', language)
			}
		`
  );
  const insertedStatements = sourceFile.insertStatements(
    index + 1,
    import_ts_dedent14.dedent`
			addRuntimeToGlobalThis(getRuntimeFromData(data))
			addRuntimeToContext(getRuntimeFromData(data))
			const { referenceLanguage } = getRuntimeFromContext()
			let { i, language } = getRuntimeFromContext()
		`
  );
  const imports = findImportDeclarations(sourceFile, "@inlang/sdk-js");
  for (const importDeclaration of imports) {
    importDeclaration.setOrder(insertedStatements.at(-1).getChildIndex() + 1);
  }
  return nodeToCode(sourceFile);
};
var transformMarkup = (config, markup) => {
  const s = new MagicString2(markup);
  const ast = markupToAst(markup);
  const inserted = insertSlotIfEmptyFile(s, ast);
  if (inserted) {
    return transformMarkup(config, s.toString());
  }
  wrapMarkupChildren(s, ast, "{#key language}$$_INLANG_WRAP_$${/key}");
  const markup1 = s.toString();
  const s1 = new MagicString2(markup1);
  const ast1 = markupToAst(markup1);
  if (!config.languageInUrl) {
    wrapMarkupChildren(s1, ast1, "{#if language || !referenceLanguage}$$_INLANG_WRAP_$${/if}");
  }
  return s1.toString();
};

// src/adapter-sveltekit/ast-transforms/+page.js.ts
var import_ts_dedent15 = __toESM(require_dist(), 1);
var addImports2 = (ast, config, root, wrapperFunctionName) => {
  addImport(ast, "$app/environment", "browser");
  addImport(ast, "@inlang/sdk-js/adapter-sveltekit/shared", wrapperFunctionName);
  if (config.languageInUrl && config.isStatic) {
    addImport(ast, "@inlang/sdk-js/adapter-sveltekit/shared", "replaceLanguageInUrl");
    addImport(
      ast,
      "@inlang/sdk-js/detectors/client",
      "initLocalStorageDetector",
      "navigatorDetector"
    );
    addImport(ast, "@sveltejs/kit", "redirect");
  }
};
var getOptions2 = (config, root) => config.languageInUrl && config.isStatic ? import_ts_dedent15.dedent`
			{
					browser,
					initDetectors: () => [navigatorDetector],
					redirect: {
						throwable: redirect,
						getPath: ({ url }, language) => replaceLanguageInUrl(new URL(url), language),
					},
			}` : import_ts_dedent15.dedent`
			{
			 		browser
			}`;
var transformPageJs = (filePath, config, code, root) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!root && !isSdkImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = root ? "initRootPageLoadWrapper" : "initLoadWrapper";
  addImports2(sourceFile, config, root, wrapperFunctionName);
  const options = root ? getOptions2(config, root) : void 0;
  wrapExportedFunction(sourceFile, options, wrapperFunctionName, "load");
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/+page.server.js.ts
var transformPageServerJs = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!isSdkImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = "initServerLoadWrapper";
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", wrapperFunctionName);
  wrapExportedFunction(sourceFile, void 0, wrapperFunctionName, "load");
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/+page.svelte.ts
var transformPageSvelte = (filePath, config, code, root) => {
  return transformSvelte(filePath, config, code);
};

// src/adapter-sveltekit/ast-transforms/+server.js.ts
var transformServerRequestJs = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!isSdkImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = "initRequestHandlerWrapper";
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", wrapperFunctionName);
  const exports = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"];
  for (const exportName of exports) {
    if (findExport(sourceFile, exportName)) {
      wrapExportedFunction(sourceFile, void 0, wrapperFunctionName, exportName);
    }
  }
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/[language].json.ts
var import_ts_dedent16 = __toESM(require_dist(), 1);
var transformLanguageJson = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  const fileName = filePathForOutput(config, filePath);
  if (findExport(sourceFile, "GET"))
    throw new InlangSdkException(import_ts_dedent16.dedent`
			The file (${fileName}) already contains a 'GET' export.
			Please remove it as 'inlang' needs to inject it's own magic here.
		`);
  const index = sourceFile.getPos();
  if (config.isStatic && config.inlang.sdk.resources.cache === "build-time")
    sourceFile.insertText(
      index,
      import_ts_dedent16.dedent`
				export const prerender = true
			`
    );
  sourceFile.insertText(
    index,
    import_ts_dedent16.dedent`
			export const GET = async ({ params: { language } }) => {
				await reloadResources()
				return json(getResource(language) || null)
			}
		`
  );
  if (config.svelteKit.version || "" >= "1.16.3") {
    addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", "initState");
    sourceFile.insertText(
      index,
      import_ts_dedent16.dedent`
				export const entries = async () => {
					const { languages } = await initState(await import('../../../../inlang.config.js'))

					return languages.map(language => ({ language }))
				}
			`
    );
  }
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", "getResource", "reloadResources");
  addImport(sourceFile, "@sveltejs/kit", "json");
  return transformServerRequestJs(filePath, config, nodeToCode(sourceFile));
};

// src/ast-transforms/utils/usage.ts
import { Node as Node8, SyntaxKind as SyntaxKind3 } from "ts-morph";
var findAllIdentifiersComingFromAnImport = (sourceFile, path5) => {
  const allIdentifiers = sourceFile.getDescendantsOfKind(SyntaxKind3.Identifier);
  return allIdentifiers.filter((identifier) => isIdentifierComingFromAnImport(identifier, path5));
};
var isIdentifierComingFromAnImport = (identifier, path5) => {
  const identifierName = identifier.getText();
  let currentNode = identifier;
  while (currentNode) {
    let nodes = [currentNode];
    if (currentNode.getParent()) {
      nodes = [...nodes, ...currentNode.getPreviousSiblings(), ...currentNode.getNextSiblings()];
    }
    const checkedNodes = nodes.map(
      (node) => checkIfImportStatementReached(node, path5, identifierName)
    );
    if (checkedNodes.includes(false))
      return false;
    if (checkedNodes.includes(true))
      return true;
    currentNode = currentNode.getParent();
  }
  return false;
};
var checkIfImportStatementReached = (node, path5, identifierName) => {
  if (shouldAbortProcessing(node, identifierName))
    return false;
  if (Node8.isImportDeclaration(node) && node.getModuleSpecifier().getLiteralText() === path5 && node.getNamedImports().some(
    (namedImport) => (namedImport.getAliasNode()?.getText() || namedImport.getName()) === identifierName
  )) {
    return true;
  }
  return void 0;
};
var shouldAbortProcessing = (node, identifierName) => {
  if (Node8.isVariableStatement(node) && node.getDeclarations().some((declaration) => declaration.getName() === identifierName)) {
    return true;
  }
  const parent = node.getParent();
  if (!parent)
    return true;
  if (Node8.isImportSpecifier(parent))
    return true;
  if (Node8.isForOfStatement(parent) || Node8.isForInStatement(parent) || Node8.isForStatement(parent)) {
    const initializer = parent.getInitializer();
    if (Node8.isVariableDeclarationList(initializer) && initializer.getDeclarations().some((identifier) => identifier.getName() === identifierName)) {
      return true;
    }
  }
  return false;
};

// src/adapter-sveltekit/ast-transforms/utils/assertions.ts
import { Node as Node9 } from "ts-morph";
var assertNodeInsideFunctionScope = (config, filePath, node) => {
  let nodeToCheck = node.getParent();
  while (nodeToCheck) {
    if (Node9.isFunctionLikeDeclaration(nodeToCheck))
      return;
    nodeToCheck = nodeToCheck.getParent();
  }
  throw new InlangSdkException(`You cannot directly access any '@inlang/sdk-js' imports in outside a function scope in this file (${filePathForOutput(
    config,
    filePath
  )}).
Please read the docs for more information on how to workaround this limitation:
https://inlang.com/documentation/sdk/sveltekit/advanced#*.js`);
};

// src/adapter-sveltekit/ast-transforms/_.js.ts
var transformJs = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  if (!isSdkImportPresent(sourceFile))
    return code;
  const identifiers = findAllIdentifiersComingFromAnImport(sourceFile, "@inlang/sdk-js");
  for (const identifier of identifiers) {
    assertNodeInsideFunctionScope(config, filePath, identifier);
    identifier.replaceWithText(`getRuntimeFromGlobalThis().${identifier.getText()}`);
  }
  removeImport(sourceFile, "@inlang/sdk-js");
  addImport(
    sourceFile,
    "@inlang/sdk-js/adapter-sveltekit/client/shared",
    "getRuntimeFromGlobalThis"
  );
  return nodeToCode(sourceFile);
};

// src/ast-transforms/utils/assertions.ts
var import_ts_dedent17 = __toESM(require_dist(), 1);
var assertNoImportsFromSdkJs = (sourceFile, filePath, type, root = false) => {
  if (isSdkImportPresent(sourceFile)) {
    throw new InlangSdkException(import_ts_dedent17.dedent`
			It is currently not supported to import something from '@inlang/sdk-js' in this file (${filePath}).
			Please read the docs for more information on how to workaround this temporary limitation:
			https://inlang.com/documentation/sdk/sveltekit/advanced${getSection(type, root)}
		`);
  }
};
var getSection = (type, root) => {
  if (root) {
    switch (type) {
      case "+layout.server.js":
        return "#/routes/+layout.server.js-(root server layout)";
      case "+layout.js":
        return "#/routes/+layout.js-(root layout)";
      case "+page.js":
        return "#/routes/+page.js-(root page)";
      case "+layout.svelte":
        return "#/routes/+layout.svelte-(root svelte layout)";
    }
  }
  switch (type) {
    case "*.server.js":
    case "*.js":
      return "#*.js";
    case "+layout.svelte":
    case "+page.svelte":
    case "*.svelte":
      return "#*.svelte";
    case "[language].json":
    case "+layout.server.js":
    case "+layout.js":
    case "hooks.server.js":
    case "+server.js":
    case "+page.server.js":
    case "+page.js":
      return "";
    default:
      return unreachable(type);
  }
};
var unreachable = (value) => {
  throw new Error(`unhandled case '${value}'`);
};

// src/adapter-sveltekit/ast-transforms/_.server.js.ts
var transformServerJs = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  assertNoImportsFromSdkJs(sourceFile, filePathForOutput(config, filePath), "*.server.js");
  return code;
};

// src/adapter-sveltekit/ast-transforms/hooks.server.js.ts
var import_ts_dedent18 = __toESM(require_dist(), 1);
var addImports3 = (sourceFile, config, wrapperFunctionName) => {
  addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/server", wrapperFunctionName);
  if (!config.isStatic && config.languageInUrl) {
    addImport(sourceFile, "@sveltejs/kit", "redirect");
    addImport(sourceFile, "@inlang/sdk-js/detectors/server", "initAcceptLanguageHeaderDetector");
    addImport(sourceFile, "@inlang/sdk-js/adapter-sveltekit/shared", "replaceLanguageInUrl");
  }
};
var getOptions3 = (config) => {
  const options = import_ts_dedent18.dedent`
	{
		inlangConfigModule: import("../inlang.config.js"),
		excludedRoutes: ${JSON.stringify(config.inlang.sdk.routing.exclude)},
		getLanguage: ${config.languageInUrl ? `({ url }) => url.pathname.split("/")[1]` : `() => undefined`},
		${!config.isStatic && config.languageInUrl ? `
			initDetectors: ({ request }) => [initAcceptLanguageHeaderDetector(request.headers)],
			redirect: {
				throwable: redirect,
				getPath: ({ url }, language) => replaceLanguageInUrl(url, language),
			},
		` : ""},
	}`;
  return nodeToCode(codeToNode(`const x = ${options}`));
};
var transformHooksServerJs = (filePath, config, code) => {
  const sourceFile = codeToSourceFile(code, filePath);
  if (isOptOutImportPresent(sourceFile))
    return code;
  const wrapperFunctionName = "initHandleWrapper";
  addImports3(sourceFile, config, wrapperFunctionName);
  const options = getOptions3(config);
  wrapExportedFunction(
    sourceFile,
    options,
    wrapperFunctionName,
    "handle",
    "({ resolve, event }) => resolve(event)"
  );
  removeImport(sourceFile, "@inlang/sdk-js");
  return nodeToCode(sourceFile);
};

// src/adapter-sveltekit/ast-transforms/index.ts
var transformCode = (filePath, config, code, { type, root }) => {
  if (!pluginOrderVerified && type.endsWith(".svelte"))
    assertCorrectPluginOrder(code);
  switch (type) {
    case "hooks.server.js":
      return transformHooksServerJs(filePath, config, code);
    case "[language].json":
      return transformLanguageJson(filePath, config, code);
    case "+server.js":
      return transformServerRequestJs(filePath, config, code);
    case "+layout.server.js":
      return transformLayoutServerJs(filePath, config, code, root);
    case "+layout.js":
      return transformLayoutJs(filePath, config, code, root);
    case "+layout.svelte":
      return transformLayoutSvelte(filePath, config, code, root);
    case "+page.server.js":
      return transformPageServerJs(filePath, config, code);
    case "+page.js":
      return transformPageJs(filePath, config, code, root);
    case "+page.svelte":
      return transformPageSvelte(filePath, config, code, root);
    case "*.server.js":
      return transformServerJs(filePath, config, code);
    case "*.js":
      return transformJs(filePath, config, code);
    case "*.svelte":
      return transformSvelte(filePath, config, code);
  }
};
var pluginOrderVerified = false;
var REGEX_SVELTE_COMPILER_INFO = /^\/\*\s.*\.svelte generated by Svelte v\d+.\d+.\d+\s\*\/$/;
var assertCorrectPluginOrder = (code) => {
  if (code.split("\n")[0]?.match(REGEX_SVELTE_COMPILER_INFO)) {
    throw new InlangSdkException(import_ts_dedent19.dedent`
			Make sure to place the inlang plugin before the svelte plugin in your vite config.
			See https://inlang.com/documentation/sdk/sveltekit#getting-started.
		`);
  }
  pluginOrderVerified = true;
};

// src/adapter-sveltekit/vite-plugin/plugin.ts
import { inspect } from "node:util";
var viteServer;
var virtualModuleId = "virtual:inlang-static";
var resolvedVirtualModuleId = "\0" + virtualModuleId;
var plugin = () => {
  return {
    name: "vite-plugin-inlang-sdk-js-sveltekit",
    // makes sure we run before vite-plugin-svelte
    enforce: "pre",
    configureServer(server) {
      viteServer = server;
    },
    config() {
      return {
        ssr: {
          // makes sure that `@inlang/sdk-js` get's transformed by vite in order
          // to be able to use `SvelteKit`'s `$app` aliases
          noExternal: ["@inlang/sdk-js"]
        }
      };
    },
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
      return;
    },
    async load(id) {
      const config = await getTransformConfig();
      if (id === resolvedVirtualModuleId) {
        return import_ts_dedent20.dedent`
					export const referenceLanguage = ${JSON.stringify(config.inlang.referenceLanguage)}
					export const languages = ${JSON.stringify(config.inlang.languages)}
					export const resources = ${JSON.stringify(
          await config.inlang.readResources({ config: config.inlang })
        )}
				`;
      }
      return;
    },
    async buildStart() {
      const config = await getTransformConfig();
      await assertAppTemplateIsCorrect(config);
      await assertRoutesFolderPathExists(config);
      const hasCreatedANewFile = await assertNecessaryFilesArePresent(config);
      if (hasCreatedANewFile) {
        setTimeout(() => {
          resetConfig();
          viteServer && viteServer.restart();
        }, 1e3);
      }
    },
    async transform(code, id) {
      const config = await getTransformConfig();
      const fileInformation = getFileInformation(config, id);
      if (!fileInformation)
        return null;
      const filePath = filePathForOutput(config, id);
      let transformedCode = code;
      try {
        transformedCode = transformCode(id, config, code, fileInformation);
      } catch (error) {
        throw new InlangTransformException(filePath, error);
      }
      if (config.debug || includesDebugImport(code)) {
        logConfig(config);
        console.info(import_ts_dedent20.dedent`
					-- INLANG DEBUG START ----------------------------------------------------------

					transformed file '${filePath}' (${fileInformation.type})

					-- INPUT -----------------------------------------------------------------------

					${code}

					-- OUTPUT ----------------------------------------------------------------------

					${code === transformedCode ? "NO TRANSFORMATIONS MADE" : transformedCode}

					-- INLANG DEBUG END ------------------------------------------------------------
				`);
      }
      return transformedCode;
    }
  };
};
var configLogged = false;
var logConfig = (config) => {
  if (configLogged)
    return;
  const { inlang: _2, ...configToLog } = config;
  console.info(import_ts_dedent20.dedent`
		-- INLANG RESOLVED CONFIG ------------------------------------------------------

		${inspect(configToLog, false, 99)}

	`);
  configLogged = true;
};
var REGEX_DEBUG_IMPORT = /import\s+["']@inlang\/sdk-js\/debug["']/;
var includesDebugImport = (code) => REGEX_DEBUG_IMPORT.test(code);
var InlangTransformException = class extends InlangSdkException {
  constructor(path5, cause) {
    super(import_ts_dedent20.dedent`
			An error occurred while transforming the code in file (${path5})

			Please open an issue on GitHub so we can investigate and improve the SDK: https://github.com/inlang/inlang/issues/new/

			Don't worry, we can probably already unblock you so you can continue working on your project.
			You can find more information about it here: https://inlang.com/documentation/sdk/sveltekit/advanced
		`);
    this.cause = cause;
  }
};

// src/adapter-sveltekit/index.ts
var adapter_sveltekit_default = plugin;
export {
  adapter_sveltekit_default as default
};
//! DON'T TOP-LEVEL IMPORT ESBUILD PLUGINS. USE DYNAMIC IMPORTS.
//! See https://github.com/inlang/inlang/issues/486
//# sourceMappingURL=index.js.map
